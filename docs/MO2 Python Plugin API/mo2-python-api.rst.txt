mobase
======

.. py:module:: mobase


Subpackages
-----------

.. toctree::
   :maxdepth: 1

   /autoapi/mobase/widgets/index


Attributes
----------

.. autoapisummary::

   mobase.GameFeatureType
   mobase.INVALID_HANDLE_VALUE
   mobase.MoVariant
   mobase.__version__


Classes
-------

.. autoapisummary::

   mobase.BSAInvalidation
   mobase.DataArchives
   mobase.EndorsedState
   mobase.ExecutableForcedLoadSetting
   mobase.ExecutableInfo
   mobase.FileInfo
   mobase.FileTreeEntry
   mobase.GameFeature
   mobase.GamePlugins
   mobase.GuessQuality
   mobase.GuessedString
   mobase.IDownloadManager
   mobase.IFileTree
   mobase.IGameFeatures
   mobase.IInstallationManager
   mobase.IModInterface
   mobase.IModList
   mobase.IModRepositoryBridge
   mobase.IOrganizer
   mobase.IPlugin
   mobase.IPluginDiagnose
   mobase.IPluginFileMapper
   mobase.IPluginGame
   mobase.IPluginInstaller
   mobase.IPluginInstallerCustom
   mobase.IPluginInstallerSimple
   mobase.IPluginList
   mobase.IPluginModPage
   mobase.IPluginPreview
   mobase.IPluginRequirement
   mobase.IPluginTool
   mobase.IProfile
   mobase.ISaveGame
   mobase.ISaveGameInfoWidget
   mobase.InstallResult
   mobase.LoadOrderMechanism
   mobase.LocalSavegames
   mobase.Mapping
   mobase.ModDataChecker
   mobase.ModDataContent
   mobase.ModRepositoryFileInfo
   mobase.ModState
   mobase.PluginRequirementFactory
   mobase.PluginSetting
   mobase.PluginState
   mobase.ProfileSetting
   mobase.ReleaseType
   mobase.SaveGameInfo
   mobase.ScriptExtender
   mobase.SortMechanism
   mobase.TrackedState
   mobase.UnmanagedMods
   mobase.VersionInfo
   mobase.VersionScheme


Functions
---------

.. autoapisummary::

   mobase.getFileVersion
   mobase.getIconForExecutable
   mobase.getProductVersion


Package Contents
----------------

.. py:class:: BSAInvalidation

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: activate(profile: IProfile) -> None
      :abstractmethod:



   .. py:method:: deactivate(profile: IProfile) -> None
      :abstractmethod:



   .. py:method:: isInvalidationBSA(name: str) -> bool
      :abstractmethod:



.. py:class:: DataArchives

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: addArchive(profile: IProfile, index: int, name: str) -> None
      :abstractmethod:


      Add an archive to the archive list.

      :param profile: Profile to add the archive to.
      :param index: Index to insert before. Use 0 for the beginning of the list or INT_MAX for
                    the end of the list).
      :param name: Name of the archive to add.



   .. py:method:: archives(profile: IProfile) -> Sequence[str]
      :abstractmethod:


      Retrieve the list of archives in the given profile.

      :param profile: Profile to retrieve archives from.

      :returns: The list of archives in the given profile.



   .. py:method:: removeArchive(profile: IProfile, name: str) -> None
      :abstractmethod:


      Remove the given archive from the given profile.

      :param profile: Profile to remove the archive from.
      :param name: Name of the archive to remove.



   .. py:method:: vanillaArchives() -> Sequence[str]
      :abstractmethod:


      Retrieve the list of vanilla archives.

      Vanilla archives are archive files that are shipped with the original
      game.

      :returns: The list of vanilla archives.



.. py:class:: EndorsedState(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(other: EndorsedState) -> bool

      Return self>=value.



   .. py:method:: __gt__(other: EndorsedState) -> bool

      Return self>value.



   .. py:method:: __int__() -> int


   .. py:method:: __le__(other: EndorsedState) -> bool

      Return self<=value.



   .. py:method:: __lt__(other: EndorsedState) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: ENDORSED_FALSE
      :value: Ellipsis



   .. py:attribute:: ENDORSED_NEVER
      :value: Ellipsis



   .. py:attribute:: ENDORSED_TRUE
      :value: Ellipsis



   .. py:attribute:: ENDORSED_UNKNOWN
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: ExecutableForcedLoadSetting(process: str, library: str)

   .. py:method:: enabled() -> bool


   .. py:method:: forced() -> bool


   .. py:method:: library() -> str


   .. py:method:: process() -> str


   .. py:method:: withEnabled(enabled: bool) -> ExecutableForcedLoadSetting


   .. py:method:: withForced(forced: bool) -> ExecutableForcedLoadSetting


.. py:class:: ExecutableInfo(title: str, binary: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo])

   .. py:method:: arguments() -> Sequence[str]


   .. py:method:: asCustom() -> ExecutableInfo


   .. py:method:: binary() -> PyQt6.QtCore.QFileInfo


   .. py:method:: isCustom() -> bool


   .. py:method:: isValid() -> bool


   .. py:method:: steamAppID() -> str


   .. py:method:: title() -> str


   .. py:method:: withArgument(argument: str) -> ExecutableInfo


   .. py:method:: withSteamAppId(app_id: str) -> ExecutableInfo


   .. py:method:: withWorkingDirectory(directory: Union[str, os.PathLike[str], PyQt6.QtCore.QDir]) -> ExecutableInfo


   .. py:method:: workingDirectory() -> PyQt6.QtCore.QDir


.. py:class:: FileInfo

   Information about a virtualized file


   .. py:property:: archive
      :type: str



   .. py:property:: filePath
      :type: str



   .. py:property:: origins
      :type: list[str]



.. py:class:: FileTreeEntry

   Represent an entry in a file tree, either a file or a directory. This class
   inherited by IFileTree so that operations on entry are the same for a file or
   a directory.

   This class provides convenience methods to query information on the file, like its
   name or the its last modification time. It also provides a convenience astree() method
   that can be used to retrieve the tree corresponding to its entry in case the entry
   represent a directory.


   .. py:class:: FileTypes(*args, **kwds)

      Bases: :py:obj:`enum.Enum`


      Enumeration of the different file type or combinations.


      .. py:method:: __and__(other: FileTreeEntry) -> FileTreeEntry


      .. py:method:: __eq__(other: object) -> bool

         Return self==value.



      .. py:method:: __ge__(other: FileTreeEntry) -> bool

         Return self>=value.



      .. py:method:: __gt__(other: FileTreeEntry) -> bool

         Return self>value.



      .. py:method:: __int__() -> int


      .. py:method:: __invert__() -> FileTreeEntry


      .. py:method:: __le__(other: FileTreeEntry) -> bool

         Return self<=value.



      .. py:method:: __lt__(other: FileTreeEntry) -> bool

         Return self<value.



      .. py:method:: __ne__(other: object) -> bool

         Return self!=value.



      .. py:method:: __or__(other: FileTreeEntry) -> FileTreeEntry


      .. py:method:: __rand__(other: FileTreeEntry) -> FileTreeEntry


      .. py:method:: __ror__(other: FileTreeEntry) -> FileTreeEntry


      .. py:method:: __rxor__(other: FileTreeEntry) -> FileTreeEntry


      .. py:method:: __str__() -> str

         Return str(self).



      .. py:method:: __xor__(other: FileTreeEntry) -> FileTreeEntry


      .. py:attribute:: DIRECTORY
         :value: Ellipsis



      .. py:attribute:: FILE
         :value: Ellipsis



      .. py:attribute:: FILE_OR_DIRECTORY
         :value: Ellipsis



      .. py:property:: name
         :type: str

         The name of the Enum member.


      .. py:property:: value
         :type: int

         The value of the Enum member.



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: detach() -> bool

      Detach this entry from its parent tree.

      :returns: True if the entry was removed correctly, False otherwise.



   .. py:method:: fileType() -> FileTreeEntry

      :returns: The filetype of this entry.



   .. py:method:: hasSuffix(suffixes: Sequence[str]) -> bool
                  hasSuffix(suffix: str) -> bool

      Check if this entry has the given suffix.

      :param suffix: Suffix to check.

      :returns: True if this entry is a file and has the given suffix.



   .. py:method:: isDir() -> bool

      :returns: True if this entry is a directory, False otherwise.



   .. py:method:: isFile() -> bool

      :returns: True if this entry is a file, False otherwise.



   .. py:method:: moveTo(tree: IFileTree) -> bool

      Move this entry to the given tree.

      :param tree: The tree to move this entry to.

      :returns: True if the entry was moved correctly, False otherwise.



   .. py:method:: name() -> str

      :returns: The name of this entry.



   .. py:method:: parent() -> IFileTree | None

      :returns: The parent tree containing this entry, or a `None` if this entry is the root

      or the parent tree is unreachable.



   .. py:method:: path(sep: str = '\\') -> str

      Retrieve the path from this entry up to the root of the tree.

      This method propagate up the tree so is not constant complexity as
      the full path is never stored.

      :param sep: The type of separator to use to create the path.

      :returns: The path from this entry to the root, including the name of this entry.



   .. py:method:: pathFrom(tree: IFileTree, sep: str = '\\') -> str

      Retrieve the path from the given tree to this entry.

      :param tree: The tree to reach, must be a parent of this entry.
      :param sep: The type of separator to use to create the path.

      :returns: The path from the given tree to this entry, including the name of this entry, or

      an empty string if the given tree is not a parent of this entry.



   .. py:method:: suffix() -> str

      Retrieve the "last" extension of this entry.

      The "last" extension is everything after the last dot in the file name.

      :returns: The last extension of this entry, or an empty string if the file has no extension

      or is directory.



   .. py:attribute:: DIRECTORY
      :type:  FileTreeEntry.FileTypes
      :value: Ellipsis



   .. py:attribute:: FILE
      :type:  FileTreeEntry.FileTypes
      :value: Ellipsis



   .. py:attribute:: FILE_OR_DIRECTORY
      :type:  FileTreeEntry.FileTypes
      :value: Ellipsis



.. py:class:: GameFeature

   Bases: :py:obj:`abc.ABC`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


.. py:class:: GamePlugins

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: getLoadOrder() -> Sequence[str]
      :abstractmethod:



   .. py:method:: lightPluginsAreSupported() -> bool
      :abstractmethod:


      :returns: True if light plugins are supported, False otherwise.



   .. py:method:: mediumPluginsAreSupported() -> bool
      :abstractmethod:


      :returns: True if medium plugins are supported, False otherwise.



   .. py:method:: readPluginLists(plugin_list: IPluginList) -> None
      :abstractmethod:



   .. py:method:: writePluginLists(plugin_list: IPluginList) -> None
      :abstractmethod:



.. py:class:: GuessQuality(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Describes how good the code considers a guess (i.e. for a mod name) this is used to
   determine if a name from another source should overwrite or not.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: FALLBACK
      :value: Ellipsis



   .. py:attribute:: GOOD
      :value: Ellipsis



   .. py:attribute:: INVALID
      :value: Ellipsis



   .. py:attribute:: META
      :value: Ellipsis



   .. py:attribute:: PRESET
      :value: Ellipsis



   .. py:attribute:: USER
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: GuessedString
              GuessedString(value: str, quality: GuessQuality = GuessQuality.USER)

   Represents a string that may be set from different places. Each time the value is
   changed a "quality" is specified to say how probable it is the value is the best choice.
   Only the best choice should be used in the end but alternatives can be queried. This
   class also allows a filter to be set. If a "guess" doesn't pass the filter, it is ignored.


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: reset() -> GuessedString
                  reset(value: str, quality: GuessQuality) -> GuessedString
                  reset(other: GuessedString) -> GuessedString

      Reset this GuessedString object by copying the given one, only
      if the given one has better quality.

      :param other: The GuessedString to copy.

      :returns: This GuessedString object.



   .. py:method:: setFilter(filter: Callable[[str], Union[str, bool]]) -> None

      Set the filter for this GuessedString.

      The filter is applied on every `update()` and can reject the new value
      altogether or modify it (by returning a new value).

      :param filter: The new filter.



   .. py:method:: update(value: str) -> GuessedString
                  update(value: str, quality: GuessQuality) -> GuessedString

      Update this GuessedString by adding a new variants with the given quality.

      If the specified quality is better than the current one, the actual value of
      the GuessedString is also updated.

      The GuessedString is only updated if the given value passes the filter.

      :param value: The new variant to add.
      :param quality: The quality of the variant.

      :returns: This GuessedString object.



   .. py:method:: variants() -> set[str]

      :returns: The list of variants for this GuessedString.



.. py:class:: IDownloadManager

   .. py:method:: downloadPath(id: int) -> str

      Retrieve the (absolute) path of the specified download.

      :param id: ID of the download.

      :returns: The absolute path to the file corresponding to the given download. This file

      may not exist yet if the download is incomplete.



   .. py:method:: onDownloadComplete(callback: Callable[[int], None]) -> bool

      Installs a handler to be called when a download completes.

      :param callback: The function to be called when a download complete. The parameter is the download ID.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onDownloadFailed(callback: Callable[[int], None]) -> bool

      Installs a handler to be called when a download fails.

      :param callback: The function to be called when a download fails. The parameter is the download ID.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onDownloadPaused(callback: Callable[[int], None]) -> bool

      Installs a handler to be called when a download is paused.

      :param callback: The function to be called when a download is paused. The parameter is the download ID.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onDownloadRemoved(callback: Callable[[int], None]) -> bool

      Installs a handler to be called when a download is removed.

      :param callback: The function to be called when a download is removed. The parameter is the download ID.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: startDownloadNexusFile(mod_id: int, file_id: int) -> int

      Download a file from www.nexusmods.com/<game>. <game> is always the game
      currently being managed.

      :param mod_id: ID of the mod to download the file from.
      :param file_id: ID of the file to download.

      :returns: An ID identifying the download.



   .. py:method:: startDownloadURLs(urls: Sequence[str]) -> int

      Download a file by url.

      The list can contain alternative URLs to allow the download manager to switch
      in case of download problems

      :param urls: List of urls to download from.

      :returns: An ID identifying the download.



.. py:class:: IFileTree

   Bases: :py:obj:`FileTreeEntry`


   Interface to classes that provides way to visualize and alter file trees. The tree
   may not correspond to an actual file tree on the disk (e.g., inside an archive,
   from a QTree Widget, ...).

   Read-only operations on the tree are thread-safe, even when the tree has not been populated
   yet.

   In order to prevent wrong usage of the tree, implementing classes may throw
   UnsupportedOperationException if an operation is not supported. By default, all operations
   are supported, but some may not make sense in many situations.

   The goal of this is not reflect the change made to a IFileTree to the disk, but child
   classes may override relevant methods to do so.

   The tree is built upon FileTreeEntry. A given tree holds shared pointers to its entries
   while each entry holds a weak pointer to its parent, this means that the descending link
   are strong (shared pointers) but the uplink are weak.

   Accessing the parent is always done by locking the weak pointer so that returned pointer
   or either null or valid. This structure implies that as long as the initial root lives,
   entry should not be destroyed, unless the entry are detached from the root and no shared
   pointers are kept.

   However, it is not guarantee that one can go up the tree from a single node entry. If the
   root node is destroyed, it will not be possible to go up the tree, even if we still have
   a valid shared pointer.


   .. py:class:: InsertPolicy(*args, **kwds)

      Bases: :py:obj:`enum.Enum`


      Create a collection of name/value pairs.

      Example enumeration:

      >>> class Color(Enum):
      ...     RED = 1
      ...     BLUE = 2
      ...     GREEN = 3

      Access them by:

      - attribute access:

        >>> Color.RED
        <Color.RED: 1>

      - value lookup:

        >>> Color(1)
        <Color.RED: 1>

      - name lookup:

        >>> Color['RED']
        <Color.RED: 1>

      Enumerations can be iterated over, and know how many members they have:

      >>> len(Color)
      3

      >>> list(Color)
      [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

      Methods can be added to enumerations, and members can have their own
      attributes -- see the documentation for details.


      .. py:method:: __eq__(other: object) -> bool

         Return self==value.



      .. py:method:: __int__() -> int


      .. py:method:: __ne__(other: object) -> bool

         Return self!=value.



      .. py:method:: __str__() -> str

         Return str(self).



      .. py:attribute:: FAIL_IF_EXISTS
         :value: Ellipsis



      .. py:attribute:: MERGE
         :value: Ellipsis



      .. py:attribute:: REPLACE
         :value: Ellipsis



      .. py:property:: name
         :type: str

         The name of the Enum member.


      .. py:property:: value
         :type: int

         The value of the Enum member.



   .. py:class:: WalkReturn(*args, **kwds)

      Bases: :py:obj:`enum.Enum`


      Enumeration that can be returned by the callback for the `walk()` method to stop the
      walking operation early.


      .. py:method:: __eq__(other: object) -> bool

         Return self==value.



      .. py:method:: __int__() -> int


      .. py:method:: __ne__(other: object) -> bool

         Return self!=value.



      .. py:method:: __str__() -> str

         Return str(self).



      .. py:attribute:: CONTINUE
         :value: Ellipsis



      .. py:attribute:: SKIP
         :value: Ellipsis



      .. py:attribute:: STOP
         :value: Ellipsis



      .. py:property:: name
         :type: str

         The name of the Enum member.


      .. py:property:: value
         :type: int

         The value of the Enum member.



   .. py:method:: __bool__() -> bool

      :returns: True if this tree is not empty, False otherwise.



   .. py:method:: __getitem__(index: int) -> FileTreeEntry

      Retrieve the entry at the given index in this tree.

      :param index: Index of the entry to retrieve, must be less than the size.

      :returns: The entry at the given index.

      :raises IndexError: If the given index is not in range for this tree.



   .. py:method:: __iter__() -> Iterator[FileTreeEntry]

      Retrieves an iterator for entries directly under this tree.

      This method does not recurse into subtrees, see `walk()` for this.

      :returns: An iterator object that can be used to iterate over entries in this tree.



   .. py:method:: __len__() -> int

      :returns: The number of entries directly under this tree.



   .. py:method:: addDirectory(path: str) -> IFileTree

      Create a new directory tree under this tree.

      This method will create missing folders in the given path and will
      not fail if the directory already exists but will fail if the given
      path contains "." or "..".
      This method invalidates iterators to this tree and all the subtrees
      present in the given path.

      :param path: Path to the directory to create.

      :returns: An IFileTree corresponding to the created directory.

      :raises RuntimeError: If the directory could not be created.



   .. py:method:: addFile(path: str, replace_if_exists: bool = False) -> FileTreeEntry

      Create a new file directly under this tree.

      This method will fail if the file already exists and `replace_if_exists` is `False`.
      This method invalidates iterators to this tree and all the subtrees present in the
      given path.

      :param path: Path to the file to create.
      :param replace_if_exists: If True and an entry already exists at the given location, it will be replaced by
                                a new entry. This will replace both files and directories.

      :returns: A FileTreeEntry corresponding to the created file.

      :raises RuntimeError: If the file could not be created.



   .. py:method:: clear() -> bool

      Delete (detach) all the entries from this tree.

      This method will go through the entries in this tree and stop at the first
      entry that cannot be deleted, this means that the tree can be partially cleared.

      :returns: True if all entries have been detached, False otherwise.



   .. py:method:: copy(entry: FileTreeEntry, path: str = '', insert_policy: IFileTree = InsertPolicy.FAIL_IF_EXISTS) -> FileTreeEntry

      Move the given entry to the given path under this tree.

      The entry must not be a parent tree of this tree. This method can also be used
      to rename entries.

      If the insert policy if FAIL_IF_EXISTS, the call will fail if an entry
      at the same location already exists. If the policy is REPLACE, an existing
      entry will be replaced. If MERGE, the entry will be merged with the existing
      one (if the entry is a file, and a file exists, the file will be replaced).

      This method invalidates iterator to this tree, to the parent tree of the given
      entry, and to subtrees of this tree if the insert policy is MERGE.

      :param entry: Entry to copy.
      :param path: The path to copy the entry to. If the path ends with / or \, the entry will
                   be copied in the corresponding directory instead of replacing it. If the
                   given path is empty (`""`), the entry is copied directly under this tree.
      :param insert_policy: Policy to use to resolve conflicts.

      :returns: The new entry (copy of the specified entry).

      :raises RuntimeError: If the entry could not be copied.



   .. py:method:: createOrphanTree(name: str = '') -> IFileTree

      Create a new orphan empty tree.

      :param name: Name of the tree.

      :returns: A new tree without any parent.



   .. py:method:: exists(path: str, type: FileTreeEntry = FileTreeEntry.FileTypes.FILE_OR_DIRECTORY) -> bool

      Check if the given entry exists.

      :param path: Path to the entry, separated by / or \.
      :param type: The type of the entry to check.

      :returns: True if the entry was found, False otherwise.



   .. py:method:: find(path: str, type: FileTreeEntry = FileTreeEntry.FileTypes.FILE_OR_DIRECTORY) -> IFileTree | FileTreeEntry | None

      Retrieve the given entry.

      If no entry exists at the given path, or if the entry is not of the right
      type, `None` is returned.

      :param path: Path to the entry, separated by / or \.
      :param type: The type of the entry to check.

      :returns: The entry at the given location, or `None` if the entry was not found or

      was not of the correct type.



   .. py:method:: insert(entry: FileTreeEntry, policy: IFileTree = InsertPolicy.FAIL_IF_EXISTS) -> bool

      Insert the given entry in this tree, removing it from its
      previous parent.

      The entry must not be this tree or a parent entry of this tree.

        - If the insert policy if `FAIL_IF_EXISTS`, the call will fail if an entry
          with the same name already exists.
        - If the policy is `REPLACE`, an existing entry will be replaced by the given entry.
        - If the policy is `MERGE`:

          - If there is no entry with the same name, the new entry is inserted.
          - If there is an entry with the same name:

            - If both entries are files, the old file is replaced by the given entry.
            - If both entries are directories, a merge is performed as if using merge().
            - Otherwise the insertion fails (two entries with different types).

      This method invalidates iterator to this tree, to the parent tree of the given
      entry, and to subtrees of this tree if the insert policy is MERGE.

      :param entry: Entry to insert.
      :param policy: Policy to use to resolve conflicts.

      :returns: True if the entry was insert, False otherwise.



   .. py:method:: merge(other: IFileTree, overwrites: bool = False) -> Union[dict[FileTreeEntry, FileTreeEntry], int]

      Merge the given tree with this tree, i.e., insert all entries
      of the given tree into this tree.

      The tree must not be this tree or a parent entry of this tree. Files present in both tree
      will be replaced by files in the given tree. After a merge, the source tree will be
      empty but still attached to its parent.

      If `overwrites` is `True`, a map from overridden files to new files will be returned.

      Note that the merge process makes no distinction between files and directories
      when merging: if a directory is present in this tree and a file from source
      is in conflict with it, the tree will be removed and the file inserted; if a file
      is in this tree and a directory from source is in conflict with it, the file will
      be replaced with the directory.

      This method invalidates iterators to this tree, all the subtrees under this tree
      present in the given path, and all the subtrees of the given source.

      :param other: Tree to merge.
      :param overwrites: If True, a mapping from overridden files to new files will be returned.

      :returns: If `overwrites` is True, a mapping from overridden files to new files, otherwise

      the number of overwritten entries.

      :raises RuntimeError: If the merge failed.



   .. py:method:: move(entry: FileTreeEntry, path: str, policy: IFileTree = InsertPolicy.FAIL_IF_EXISTS) -> bool

      Move the given entry to the given path under this tree.

      The entry must not be a parent tree of this tree. This method can also be used
      to rename entries.

      If the insert policy if FAIL_IF_EXISTS, the call will fail if an entry
      at the same location already exists. If the policy is REPLACE, an existing
      entry will be replaced. If MERGE, the entry will be merged with the existing
      one (if the entry is a file, and a file exists, the file will be replaced).

      This method invalidates iterator to this tree, to the parent tree of the given
      entry, and to subtrees of this tree if the insert policy is MERGE.

      :param entry: Entry to move.
      :param path: The path to move the entry to. If the path ends with / or \, the entry will
                   be inserted in the corresponding directory instead of replacing it. If the
                   given path is empty (`""`), this is equivalent to `insert()`.
      :param policy: Policy to use to resolve conflicts.

      :returns: True if the entry was moved correctly, False otherwise.



   .. py:method:: pathTo(entry: FileTreeEntry, sep: str = '\\') -> str

      Retrieve the path from this tree to the given entry.

      :param entry: The entry to reach, must be in this tree.
      :param sep: The type of separator to use to create the path.

      :returns: The path from this tree to the given entry, including the name of the entry, or

      an empty string if the given entry was not found under this tree.



   .. py:method:: remove(name: str) -> bool
                  remove(entry: FileTreeEntry) -> bool

      Delete the given entry.

      :param entry: Entry to delete. The entry must belongs to this tree (and not to a subtree).

      :returns: True if the entry was deleted, False otherwise.



   .. py:method:: removeAll(names: Sequence[str]) -> int

      Delete the entries with the given names from the tree.

      This method does not recurse into subtrees, so only entries accessible
      directly from this tree will be removed. This method invalidates iterators.

      :param names: Names of the entries to delete.

      :returns: The number of deleted entry.



   .. py:method:: removeIf(filter: Callable[[FileTreeEntry], bool]) -> int

      Delete entries matching the given predicate from the tree.

      This method does not recurse into subtrees, so only entries accessible
      directly from this tree will be removed. This method invalidates iterators.

      :param filter: Predicate that should return true for entries to delete.

      :returns: The number of deleted entry.



   .. py:method:: walk(callback: Callable[[str, FileTreeEntry], IFileTree], sep: str = '\\') -> None

      Walk this tree, calling the given function for each entry in it.

      The given callback will be called with two parameters: the path from this tree to the given entry
      (with a trailing separator, not including the entry name), and the actual entry. The method returns
      a `WalkReturn` object to indicates what to do.

      :param callback: Method to call for each entry in the tree.
      :param sep: Type of separator to use to construct the path.



   .. py:attribute:: CONTINUE
      :type:  IFileTree.WalkReturn
      :value: Ellipsis



   .. py:attribute:: FAIL_IF_EXISTS
      :type:  IFileTree.InsertPolicy
      :value: Ellipsis



   .. py:attribute:: MERGE
      :type:  IFileTree.InsertPolicy
      :value: Ellipsis



   .. py:attribute:: REPLACE
      :type:  IFileTree.InsertPolicy
      :value: Ellipsis



   .. py:attribute:: SKIP
      :type:  IFileTree.WalkReturn
      :value: Ellipsis



   .. py:attribute:: STOP
      :type:  IFileTree.WalkReturn
      :value: Ellipsis



.. py:class:: IGameFeatures

   Interface for the game features, accessible through IOrganizer.gameFeatures().


   .. py:method:: gameFeature(feature_type: Type[GameFeatureType]) -> GameFeatureType

      Retrieve the given game feature, if one exists.

      :param feature_type: The class of feature to retrieve.

      :returns: The game feature corresponding to the given type, or `None` if the feature is

      not available.



   .. py:method:: registerFeature(games: Sequence[str], feature: GameFeature, priority: int, replace: bool = False) -> bool
                  registerFeature(game: IPluginGame, feature: GameFeature, priority: int, replace: bool = False) -> bool
                  registerFeature(feature: GameFeature, priority: int, replace: bool = False) -> bool

      Register game feature for all games.

      This method register a game feature to combine or replace with other features
      of the same kind. Some features are merged (e.g., ModDataContent,
      ModDataChecker), while other override previous features (e.g., SaveGameInfo).

      For features that can be combined, the priority argument indicates the order of
      priority (e.g., the order of the checks for ModDataChecker). For other features,
      the feature with the highest priority will be used. The features provided by the
      game plugin itself always have lowest priority.

      The feature is associated to the plugin that registers it, if the plugin is
      disabled, the feature will not be available.

      This function will return True if the feature was registered, even if the
      feature is not used du to its low priority.

      :param feature: Game feature to register.
      :param priority: Priority of the game feature. If the plugin registering the feature
                       is a game plugin, this parameter is ignored.
      :param replace: If True, remove features of the same kind registered by the current plugin,
                      otherwise add the feature alongside existing ones.

      :returns: True if the game feature was properly registered, False otherwise.



   .. py:method:: unregisterFeature(feature: GameFeature) -> bool

      Unregister the given game feature.

      This function is safe to use even if the given feature was never registered.

      :param feature: Feature to unregister.

      :returns: True if the feature was successfully unregistered, False otherwise.



   .. py:method:: unregisterFeatures(feature_type: Type[GameFeatureType]) -> int

      Unregister all features of the given type registered by the calling plugin.

      This function is safe to use even if the plugin has no feature of the given type
      register.

      :param feature_type: The class of feature to unregister.

      :returns: The number of unregistered features.



.. py:class:: IInstallationManager

   .. py:method:: createFile(entry: FileTreeEntry) -> str

      Create a new file on the disk corresponding to the given entry.

      This method can be used by installer that needs to create files that are not in the original
      archive. At the end of the installation, if there are entries in the final tree that were used
      to create files, the corresponding files will be moved to the mod folder.

      Temporary files corresponding to created files are automatically cleaned up at the end of
      the installation.

      :param entry: The entry for which a temporary file should be created.

      :returns: The path to the created file, or an empty string if the file could not be created.



   .. py:method:: extractFile(entry: FileTreeEntry, silent: bool = False) -> str

      Extract the specified file from the currently opened archive to a temporary
      location.

      This method cannot be used to extract directory.

      The call will fail with an exception if no archive is open (plugins deriving from
      IPluginInstallerSimple can rely on that, custom installers should not). The temporary
      file is automatically cleaned up after the installation. This call can be very slow
      if the archive is large and "solid".

      :param entry: Entry corresponding to the file to extract.
      :param silent: If true, the dialog showing extraction progress will not be shown.

      :returns: The absolute path to the temporary file, or an empty string if the file was not extracted.



   .. py:method:: extractFiles(entries: list[FileTreeEntry], silent: bool = False) -> Sequence[str]

      Extract the specified files from the currently opened archive to a temporary
      location.

      This method cannot be used to extract directories.

      The call will fail with an exception if no archive is open (plugins deriving from
      IPluginInstallerSimple can rely on that, custom installers should not). The temporary
      files are automatically cleaned up after the installation. This call can be very slow
      if the archive is large and "solid".

      :param entries: Entries corresponding to the files to extract.
      :param silent: If true, the dialog showing extraction progress will not be shown.

      :returns: A list containing absolute paths to the temporary files.



   .. py:method:: getSupportedExtensions() -> Sequence[str]

      :returns: The extensions of archives supported by this installation manager.



   .. py:method:: installArchive(mod_name: GuessedString, archive: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo], mod_id: int = 0) -> tuple[InstallResult, str, int]

      Install the given archive.

      :param mod_name: Suggested name of the mod.
      :param archive: Path to the archive to install.
      :param mod_id: ID of the mod, if available.

      :returns: The result of the installation.



.. py:class:: IModInterface

   .. py:method:: absolutePath() -> str

      :returns: Absolute path to the mod to be used in file system operations.



   .. py:method:: addCategory(name: str) -> None

      Assign a category to the mod. If the named category does not exist it is created.

      :param name: Name of the new category to assign.



   .. py:method:: addNexusCategory(category_id: int) -> None

      Set the category id from a nexus category id. Conversion to MO ID happens internally.

      If a mapping is not possible, the category is set to the default value.

      :param category_id: The Nexus category ID.



   .. py:method:: categories() -> Sequence[str]

      :returns: The list of categories this mod belongs to.



   .. py:method:: clearPluginSettings(plugin_name: str) -> dict[str, MoVariant]

      Remove all the settings of the specified plugin this mod.

      :param plugin_name: Name of the plugin for which settings should be removed. This should always be `IPlugin.name()`
                          unless you have a really good reason to access settings of another plugin.

      :returns: The old settings from the given plugin, as returned by `pluginSettings()`.



   .. py:method:: color() -> PyQt6.QtGui.QColor

      :returns: The color of the 'Notes' column chosen by the user.



   .. py:method:: comments() -> str

      :returns: The comments for this mod, if any.



   .. py:method:: converted() -> bool

      Check if the mod was marked as converted by the user.

      When a mod is for a different game, a flag is shown to users to warn them, but
      they can mark mods as converted to remove this flag.

      :returns: True if this mod was marked as converted by the user.



   .. py:method:: endorsedState() -> EndorsedState

      :returns: The endorsement state of this mod.



   .. py:method:: fileTree() -> IFileTree

      Retrieve a file tree corresponding to the underlying disk content of this mod.

      The file tree should not be cached by plugins since it is already and updated when
      required.

      :returns: A file tree representing the content of this mod.



   .. py:method:: gameName() -> str

      Retrieve the short name of the game associated with this mod. This may differ
      from the current game plugin (e.g. you can install a Skyrim LE game in a SSE
      installation).

      :returns: The name of the game associated with this mod.



   .. py:method:: ignoredVersion() -> VersionInfo

      :returns: The ignored version of this mod (for update), or an invalid version if the user

      did not ignore version for this mod.



   .. py:method:: installationFile() -> str

      :returns: The absolute path to the file that was used to install this mod.



   .. py:method:: isBackup() -> bool

      :returns: True if this mod represents a backup.



   .. py:method:: isForeign() -> bool

      :returns: True if this mod represents a foreign mod, not managed by MO2.



   .. py:method:: isOverwrite() -> bool

      :returns: True if this mod represents the overwrite mod.



   .. py:method:: isSeparator() -> bool

      :returns: True if this mod represents a separator.



   .. py:method:: name() -> str

      :returns: The name of this mod.



   .. py:method:: newestVersion() -> VersionInfo

      :returns: The newest version of this mod (as known by MO2). If this matches version(),

      then the mod is up-to-date.



   .. py:method:: nexusId() -> int

      :returns: The Nexus ID of this mod.



   .. py:method:: notes() -> str

      :returns: The notes for this mod, if any.



   .. py:method:: pluginSetting(plugin_name: str, key: str, default: MoVariant = None) -> MoVariant

      Retrieve the specified setting in this mod for a plugin.

      :param plugin_name: Name of the plugin for which to retrieve a setting. This should always be `IPlugin.name()`
                          unless you have a really good reason to access settings of another plugin.
      :param key: Identifier of the setting.
      :param default: The default value to return if the setting does not exist.

      :returns: The setting, if found, or the default value.



   .. py:method:: pluginSettings(plugin_name: str) -> dict[str, MoVariant]

      Retrieve the settings in this mod for a plugin.

      :param plugin_name: Name of the plugin for which to retrieve settings. This should always be `IPlugin.name()`
                          unless you have a really good reason to access settings of another plugin.

      :returns: A map from setting key to value. The map is empty if there are not settings for this mod.



   .. py:method:: primaryCategory() -> int

      :returns: The ID of the primary category of this mod.



   .. py:method:: removeCategory(name: str) -> bool

      Unassign a category from this mod.

      :param name: Name of the category to remove.

      :returns: True if the category was removed, False otherwise (e.g. if no such category

      was assigned).



   .. py:method:: repository() -> str

      :returns: The name of the repository from which this mod was installed.



   .. py:method:: setGameName(name: str) -> None

      Set the source game of this mod.

      :param name: The new source game short name of this mod.



   .. py:method:: setIsEndorsed(endorsed: bool) -> None

      Set endorsement state of the mod.

      :param endorsed: New endorsement state of this mod.



   .. py:method:: setNewestVersion(version: VersionInfo) -> None

      Set the latest known version of this mod.

      :param version: The latest known version of this mod.



   .. py:method:: setNexusID(nexus_id: int) -> None

      Set the Nexus ID of this mod.

      :param nexus_id: Thew new Nexus ID of this mod.



   .. py:method:: setPluginSetting(plugin_name: str, key: str, value: MoVariant) -> bool

      Set the specified setting in this mod for a plugin.

      :param plugin_name: Name of the plugin for which to retrieve a setting. This should always be `IPlugin.name()`
                          unless you have a really good reason to access settings of another plugin.
      :param key: Identifier of the setting.
      :param value: New value for the setting to set.

      :returns: True if the setting was set correctly, False otherwise.



   .. py:method:: setUrl(url: str) -> None

      Set the URL of this mod.

      :param url: The URL of this mod.



   .. py:method:: setVersion(version: VersionInfo) -> None

      Set the version of this mod.

      :param version: The new version of this mod.



   .. py:method:: trackedState() -> TrackedState

      :returns: The tracked state of this mod.



   .. py:method:: url() -> str

      :returns: The URL of this mod, or an empty QString() if no URL is associated

      with this mod.



   .. py:method:: validated() -> bool

      Check if the mod was marked as validated by the user.

      MO2 uses ModDataChecker to check the content of mods, but sometimes these fail, in
      which case mods are incorrectly marked as 'not containing valid games data'. Users can
      choose to mark these mods as valid to hide the warning / flag.

      :returns: True if th is mod was marked as containing valid game data.



   .. py:method:: version() -> VersionInfo

      :returns: The current version of this mod.



.. py:class:: IModList

   Interface to the mod-list.

   All api functions in this interface work need the internal name of a mod to find a
   mod. For regular mods (mods the user installed) the display name (as shown to the user)
   and internal name are identical. For other mods (non-MO mods) there is currently no way
   to translate from display name to internal name because the display name might not me un-ambiguous.


   .. py:method:: allMods() -> Sequence[str]

      :returns: A list containing the internal names of all installed mods.



   .. py:method:: allModsByProfilePriority(profile: IProfile | None = None) -> Sequence[str]

      :returns: The list of mod (names), sorted according to the current profile priorities.



   .. py:method:: displayName(name: str) -> str

      Retrieve the display name of a mod from its internal name.

      If you received an internal name from the API (e.g. `IPluginList.origin`) then you should use
      that name to identify the mod in all other api calls but use this function to retrieve the name
      to show to the user.

      :param name: Internal name of the mod.

      :returns: The display name of the given mod.



   .. py:method:: getMod(name: str) -> IModInterface

      Retrieve an interface to a mod using its name.

      :param name: Name of the mod to retrieve.

      :returns: An interface to the given mod, or `None` if there is no mod with this name.



   .. py:method:: onModInstalled(callback: Callable[[IModInterface], None]) -> bool

      Install a new handler to be called when a new mod is installed.

      :param callback: The function to call when a mod is installed. The parameter of the function is the name of the
                       newly installed mod.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onModMoved(callback: Callable[[str, int, int], None]) -> bool

      Install a handler to be called when a mod is moved.

      :param callback: The function to call when a mod is moved. The first argument is the internal name of the
                       mod, the second argument the old priority and the third argument the new priority.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onModRemoved(callback: Callable[[str], None]) -> bool

      Install a new handler to be called when a mod is removed.

      :param callback: The function to call when a mod is removed. The parameter of the function is the name of the
                       removed mod.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onModStateChanged(callback: Callable[[dict[str, ModState]], None]) -> bool

      Install a handler to be called when mod states change (enabled/disabled, endorsed, ...).

      :param callback: The function to call when the states of mod change. The argument is a map containing the
                       mods whose states have changed. Keys are internal mod names and values are mod states.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: priority(name: str) -> int

      Retrieve the priority of a mod.

      :param name: Internal name of the mod.

      :returns: The priority of the given mod.



   .. py:method:: removeMod(mod: IModInterface) -> bool

      Remove a mod (from disc and from the UI).

      :param mod: The mod to remove.

      :returns: True if the mod was removed, False otherwise.



   .. py:method:: renameMod(mod: IModInterface, name: str) -> IModInterface

      Rename the given mod.

      This method usually invalidates the given mod so you should use the returned value
      after calling it instead of the passed value.

      :param mod: The mod to rename.
      :param name: The new name of the mod.

      :returns: A valid reference to the given mod after renaming it.



   .. py:method:: setActive(names: Sequence[str], active: bool) -> int
                  setActive(name: str, active: bool) -> bool

      Enable or disable a mod.

      Calling this will cause MO to re-evaluate its virtual file system so this is
      a fairly expensive call.

      :param name: Internal name of the mod to enable or disable.
      :param active: True to enable the mod, False to disable it.

      :returns: True on success, False otherwise.



   .. py:method:: setPriority(name: str, priority: int) -> bool

      Change the priority of a mod.

      `priority` is the new priority after the move. Keep in mind that the mod disappears from its
      old location and all mods with higher priority than the moved mod decrease in priority by one.

      :param name: Internal name of the mod.
      :param priority: The new priority of the mod.

      :returns: True if the priority was changed, False otherwise (if the name or priority were invalid).



   .. py:method:: state(name: str) -> ModState

      Retrieve the state of a mod.

      :param name: Internal name of the mod.

      :returns: The state of the given mod.



.. py:class:: IModRepositoryBridge

   Bases: :py:obj:`PyQt6.QtCore.QObject`


   .. py:method:: __getattr__(arg0: str) -> object


   .. py:method:: _object() -> PyQt6.QtCore.QObject

      :returns: The underlying `QObject` for the bridge.



   .. py:method:: requestDescription(game_name: str, mod_id: int, user_data: MoVariant) -> None

      Request description of a mod.

      :param game_name: Name of the game containing the mod.
      :param mod_id: Nexus ID of the mod.
      :param user_data: User data to be returned with the result.



   .. py:method:: requestDownloadURL(game_name: str, mod_id: int, file_id: int, user_data: MoVariant) -> None

      Request download URL for mod file.0

      :param game_name: Name of the game containing the mod.
      :param mod_id: Nexus ID of the mod.
      :param file_id: ID of the file for which a URL should be returned.
      :param user_data: User data to be returned with the result.



   .. py:method:: requestFileInfo(game_name: str, mod_id: int, file_id: int, user_data: MoVariant) -> None

      :param game_name: Name of the game containing the mod.
      :param mod_id: Nexus ID of the mod.
      :param file_id: ID of the file for which information is requested.
      :param user_data: User data to be returned with the result.



   .. py:method:: requestFiles(game_name: str, mod_id: int, user_data: MoVariant) -> None

      Request the list of files belonging to a mod.

      :param game_name: Name of the game containing the mod.
      :param mod_id: Nexus ID of the mod.
      :param user_data: User data to be returned with the result.



   .. py:method:: requestToggleEndorsement(game_name: str, mod_id: int, mod_version: str, endorse: bool, user_data: MoVariant) -> None

      :param game_name: Name of the game containing the mod.
      :param mod_id: Nexus ID of the mod.
      :param mod_version: Version of the mod.
      :param endorse:
      :param user_data: User data to be returned with the result.



   .. py:attribute:: descriptionAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: downloadURLsAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: endorsementToggled
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: endorsementsAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: fileInfoAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: filesAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: requestFailed
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: trackedModsAvailable
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



   .. py:attribute:: trackingToggled
      :type:  PyQt6.QtCore.pyqtSignal
      :value: Ellipsis



.. py:class:: IOrganizer

   Interface to class that provides information about the running session
   of Mod Organizer to be used by plugins.


   .. py:method:: appVersion() -> VersionInfo

      :returns: The running version of Mod Organizer.



   .. py:method:: basePath() -> str

      :returns: The absolute path to the base directory of Mod Organizer.



   .. py:method:: createMod(name: GuessedString) -> IModInterface

      Create a new mod with the specified name.

      If a mod with the same name already exists, the user will be queried. If the user chooses
      to merge or replace, the call will succeed, otherwise the call will fail.

      :param name: Name of the mod to create.

      :returns: An interface to the newly created mod that can be used to modify it, or `None` if the mod

      could not be created.



   .. py:method:: createNexusBridge() -> IModRepositoryBridge

      Create a new Nexus interface.

      :returns: The newly created Nexus interface.



   .. py:method:: downloadManager() -> IDownloadManager

      :returns: The interface to the download manager.



   .. py:method:: downloadsPath() -> str

      :returns: The absolute path to the download directory.



   .. py:method:: findFileInfos(path: Union[str, os.PathLike[str], PyQt6.QtCore.QDir], filter: Callable[[FileInfo], bool]) -> Sequence[FileInfo]

      Find files in the virtual directory matching the specified filter.

      :param path: The path to search in (relative to the 'data' folder).
      :param filter: The function to use to filter files. Should return True for the files to keep.

      :returns: The list of `QFileInfo` corresponding to the matching files.



   .. py:method:: findFiles(path: Union[str, os.PathLike[str], PyQt6.QtCore.QDir], filter: Callable[[str], bool]) -> Sequence[str]
                  findFiles(path: Union[str, os.PathLike[str], PyQt6.QtCore.QDir], patterns: Sequence[str]) -> Sequence[str]
                  findFiles(path: Union[str, os.PathLike[str], PyQt6.QtCore.QDir], pattern: str) -> Sequence[str]

      Find files in the given folder that matches the given glob pattern.

      :param path: The path to search in (relative to the 'data' folder).
      :param pattern: The glob pattern to use to filter files.

      :returns: The list of matching files.



   .. py:method:: gameFeatures() -> IGameFeatures

      :returns: The interface to the game features.



   .. py:method:: getFileOrigins(filename: str) -> Sequence[str]

      Retrieve the file origins for the specified file.

      The origins are listed with their internal name. The internal name of a mod can differ
      from the display name for disambiguation.

      :param filename: Path to the file to retrieve origins for (relative to the 'data' folder).

      :returns: The list of origins that contain the specified file, sorted by their priority.



   .. py:method:: getGame(name: str) -> IPluginGame

      Retrieve the game plugin matching the given name.

      :param name: Name of the game (short name).

      :returns: The plugin for the given game, or `None` if none was found.



   .. py:method:: getPluginDataPath() -> str
      :staticmethod:


      :returns: The directory for plugin data, typically plugins/data.



   .. py:method:: installMod(filename: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo], name_suggestion: str = '') -> IModInterface

      Install a mod archive at the specified location.

      :param filename: Absolute filepath to the archive to install.
      :param name_suggestion: Suggested name for this mod. This can still be changed by the user.

      :returns: An interface to the new installed mod, or `None` if no installation took place (canceled or failure).



   .. py:method:: isPluginEnabled(plugin: IPlugin) -> bool
                  isPluginEnabled(plugin: str) -> bool

      Check if a plugin is enabled.

      :param plugin: The name of the plugin to check.

      :returns: True if the plugin is enabled, False otherwise.



   .. py:method:: listDirectories(directory: str) -> Sequence[str]

      Retrieve the list of (virtual) subdirectories in the given path.

      :param directory: Path to the directory to list (relative to the 'data' folder).

      :returns: The list of directories in the given directory.



   .. py:method:: managedGame() -> IPluginGame

      :returns: The plugin corresponding to the current game.



   .. py:method:: modDataChanged(mod: IModInterface) -> None

      Notify the organizer that the given mod has changed.

      :param mod: The mod that has changed.



   .. py:method:: modList() -> IModList

      :returns: The interface to the mod list.



   .. py:method:: modsPath() -> str

      :returns: The (absolute) path to the mods directory.



   .. py:method:: onAboutToRun(callback: Callable[[str, PyQt6.QtCore.QDir, str], bool]) -> bool
                  onAboutToRun(callback: Callable[[str], bool]) -> bool

      Install a new handler to be called when an application is about to run.

      Multiple handlers can be installed. If any of the handler returns `False`, the
      application will not run.

      :param callback: The function to call when an application is about to run. The parameter
                       is the absolute path to the application to run. The function can return False
                       to prevent the application from running.

      :returns: True if the handler was installed properly (there are currently no reasons for

      this to fail).



   .. py:method:: onFinishedRun(callback: Callable[[str, int], None]) -> bool

      Install a new handler to be called when an application has finished running.

      :param callback: The function to call when an application has finished running. The first parameter is the absolute
                       path to the application, and the second parameter is the exit code of the application.

      :returns: True if the handler was installed properly (there are currently no reasons for

      this to fail).



   .. py:method:: onNextRefresh(callback: Callable[[], None], immediate_if_possible: bool = True) -> bool

      Install a new handler to be called on the next refresh or immediately.

      :param callback: Function to call on the next refresh (or immediately).
      :param immediate_if_possible: If True, immediately run the callback if no refresh is currently running.

      :returns: True if the handler was installed properly (there are currently no reasons for

      this to fail).



   .. py:method:: onPluginDisabled(callback: Callable[[IPlugin], None]) -> None
                  onPluginDisabled(name: str, callback: Callable[[], None]) -> None

      Install a new handler to be called when the given plugin is disabled.

      :param name: Name of the plugin to watch.
      :param callback: The function to call when the plugin is disabled.



   .. py:method:: onPluginEnabled(callback: Callable[[IPlugin], None]) -> None
                  onPluginEnabled(name: str, callback: Callable[[], None]) -> None

      Install a new handler to be called when the given plugin is enabled.

      :param name: Name of the plugin to watch.
      :param callback: The function to call when the plugin is enabled.



   .. py:method:: onPluginSettingChanged(callback: Callable[[str, str, MoVariant, MoVariant], None]) -> bool

      Install a new handler to be called when a plugin setting is changed.

      :param callback: The function to call when a plugin setting is changed. The parameters are: The name of the plugin, the
                       name of the setting, the old value (or `None` if the setting did not exist before) and the new value
                       of the setting (or `None` if the setting has been removed).

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onProfileChanged(callback: Callable[[IProfile, IProfile], None]) -> bool

      Install a new handler to be called when the current profile is changed.

      The function is called when the profile is changed but some operations related to
      the profile might not be finished when this is called (e.g., the virtual file system
      might not be up-to-date).

      :param callback: The function to call when the current profile is changed. The first parameter is the old profile (can
                       be `None`, e.g. at startup), and the second parameter is the new profile (cannot be `None`).

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onProfileCreated(callback: Callable[[IProfile], None]) -> bool

      Install a new handler to be called when a new profile is created.

      :param callback: The function to call when a new profile is created. The parameter is the new profile (can be
                       a temporary object and should not be stored).

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onProfileRemoved(callback: Callable[[str], None]) -> bool

      Install a new handler to be called when a profile is remove.

      The callbacks are called after the profile has been removed so the profile is not accessible
      anymore.

      :param callback: The function to call when a profile is remove. The parameter is the name of the profile that was
                       removed.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onProfileRenamed(callback: Callable[[IProfile, str, str], None]) -> bool

      Install a new handler to be called when a profile is renamed.

      :param callback: The function to call when a profile is renamed. The first parameter is the profile being renamed,
                       the second parameter the previous name and the third parameter the new name.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onUserInterfaceInitialized(callback: Callable[[PyQt6.QtWidgets.QMainWindow], None]) -> bool

      Install a new handler to be called when the UI has been fully initialized.

      :param callback: The function to call when the user-interface has been fully initialized. The parameter is the main
                       window of the application (`QMainWindow`).

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: overwritePath() -> str

      :returns: The (absolute) path to the overwrite directory.



   .. py:method:: persistent(plugin_name: str, key: str, default: MoVariant = None) -> MoVariant

      Retrieve the specified persistent value for a plugin.

      A persistent is an arbitrary value that the plugin can set and retrieve that is persistently stored
      by the main application. There is no UI for the user to change this value but they can directly access
      the storage

      :param plugin_name: Name of the plugin for which to retrieve the value. This should always be `IPlugin.name()` unless you have a
                          really good reason to access data of another mod AND if you can verify that plugin is actually installed.
      :param key: Identifier of the setting.
      :param default: Default value to return if the key is not set (yet).

      :returns: The value corresponding to the given persistent setting, or `def` is the key is not found.



   .. py:method:: pluginDataPath() -> str

      Retrieve the path to a directory where plugin data should be stored.

      For python plugins, it is recommended to use a dedicated folder (per plugin) if you need to
      store data (resources, or multiple python files).

      :returns: Path to a directory where plugin data should be stored.



   .. py:method:: pluginList() -> IPluginList

      :returns: The plugin list interface.



   .. py:method:: pluginSetting(plugin_name: str, key: str) -> MoVariant

      Retrieve settings of plugins.

      :param plugin_name: Name of the plugin to retrieve the setting for.
      :param key: Name of the setting to retrieve the value for.

      :returns: The value of the setting.



   .. py:method:: profile() -> IProfile

      :returns: The interface to the current profile.



   .. py:method:: profileName() -> str

      :returns: The name of the current profile, or an empty string if no profile has been loaded (yet).



   .. py:method:: profilePath() -> str

      :returns: The absolute path to the active profile or an empty string if no profile has been loaded (yet).



   .. py:method:: refresh(save_changes: bool = True) -> None

      Refresh the internal mods file structure from disk. This includes the mod list, the plugin
      list, data tab and other smaller things like problems button (same as pressing F5).

      The main part of the refresh of the mods file structure, mod list and plugin list is done
      asynchronously, so you should not expect them to be up-to-date when this function returns.

      :param save_changes: If True, the relevant profile information is saved first (enabled mods and order of mods).



   .. py:method:: resolvePath(filename: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]) -> str

      Resolves a path relative to the virtual data directory to its absolute real path.

      :param filename: Path to resolve.

      :returns: The absolute real path, or an empty string if the path was not found.



   .. py:method:: setPersistent(plugin_name: str, key: str, value: MoVariant, sync: bool = True) -> None

      Set the specified persistent value for a plugin.

      This does not update the in-memory value for this setting, see `setPluginSetting()` for this.

      :param plugin_name: Name of the plugin for which to change a value. This should always be `IPlugin.name()` unless you have a
                          really good reason to access data of another mod AND if you can verify that plugin is actually installed.
      :param key: Identifier of the setting.
      :param value: New value for the setting.
      :param sync: If True, the storage is immediately written to disc. This costs performance but is safer against data loss.



   .. py:method:: setPluginSetting(plugin_name: str, key: str, value: MoVariant) -> None

      Set the specified setting for a plugin.

      This automatically notify handlers register with `onPluginSettingChanged`, so you do not have to do it yourself.

      :param plugin_name: Name of the plugin for which to change a value. This should always be `IPlugin.name()` unless you have a
                          really good reason to access data of another mod AND if you can verify that plugin is actually installed.
      :param key: Identifier of the setting.
      :param value: New value for the setting.



   .. py:method:: startApplication(executable: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo], args: Sequence[str] = [], cwd: Union[str, os.PathLike[str], PyQt6.QtCore.QDir] = '', profile: str = '', forcedCustomOverwrite: str = '', ignoreCustomOverwrite: bool = False) -> int

      Starts an application with virtual filesystem active.

      :param executable: Name or path of the executable. If this is only a filename, it will only work if it has been configured
                         in MO as an executable. If it is a relative path it is expected to be relative to the game directory.
      :param args: Arguments to pass to the executable. If the list is empty, and `executable` refers to a configured executable,
                   the configured arguments are used.
      :param cwd: The working directory for the executable. If this is empty, the path to the executable is used unless `executable`
                  referred to a configured MO executable, in which case the configured cwd is used.
      :param profile: Profile to use. If this is empty (the default) the current profile is used.
      :param forcedCustomOverwrite: The mod to set as the custom overwrite, regardless of what the profile has configured.
      :param ignoreCustomOverwrite: Set to true to ignore the profile's configured custom overwrite.

      :returns: The handle to the started application, or 0 if the application failed to start.



   .. py:method:: virtualFileTree() -> IFileTree

      Retrieve a IFileTree object representing the virtual file tree.

      :returns: An IFileTree representing the virtual file tree.



   .. py:method:: waitForApplication(handle: int, refresh: bool = True) -> tuple[bool, int]

      Wait for the application corresponding to the given handle to finish.

      This will always show the lock overlay, regardless of whether the
      user has disabled locking in the setting, so use this with care.
      Note that the lock overlay will always allow the user to unlock, in
      which case this will return False.

      :param handle: Handle of the application to wait for (as returned by `startApplication()`).
      :param refresh: Whether ModOrganizer should refresh after the process completed or not.

      :returns: A tuple `(result, exitcode)`, where `result` is a boolean indicating if the application

      completed successfully, and `exitcode` is the exit code of the application.



.. py:class:: IPlugin

   Bases: :py:obj:`abc.ABC`


   Base class for all plugins.


   .. py:method:: author() -> str
      :abstractmethod:


      :returns: The name of the plugin author.



   .. py:method:: description() -> str
      :abstractmethod:


      :returns: The description for this plugin.



   .. py:method:: enabledByDefault() -> bool

      Check whether this plugin should be enabled by default.

      :returns: True if this plugin should be enabled by default, False otherwise.



   .. py:method:: init(organizer: IOrganizer) -> bool
      :abstractmethod:


      Initialize this plugin.

      Note that this function may never be called if no `IOrganizer` is available
      at that time, such as when creating the first instance in MO.

      Plugins will probably want to store the organizer pointer. It is guaranteed
      to be valid as long as the plugin is loaded.

      These functions may be called before `init()`:

        - `name()`
        - see `IPluginGame` for more.

      :param organizer: The main organizer interface.

      :returns: True if the plugin was initialized correctly, False otherwise.



   .. py:method:: localizedName() -> str

      Retrieve the localized name of the plugin.

      Unlike `name()`, this method can (and should!) return a localized name for the plugin.
      This method returns name() by default.

      :returns: The localized name of the plugin.



   .. py:method:: master() -> str

      Retrieve the master plugin of this plugin.

      It is often easier to implement a functionality as multiple plugins in MO2, but ship the
      plugins together, e.g. as a Python module or using `createFunctions()`. In this case, having
      a master plugin (one of the plugin, or a separate one) tells MO2 that these plugins are
      linked and should also be displayed together in the UI. If MO2 ever implements automatic
      updates for plugins, the `master()` plugin will also be used for this purpose.

      :returns: The master plugin of this plugin, or a null pointer if this plugin does not have a master.



   .. py:method:: name() -> str
      :abstractmethod:


      Retrieve the name of the plugin.

      The name of the plugin is used for internal storage purpose so it should not change,
      and it should be static. In particular, you should not use a localized string (`tr()`)
      for the plugin name.

      In the future, we will provide a way to localized plugin names using a distinct method,
      such as `localizedName()`.

      :returns: The name of the plugin.



   .. py:method:: requirements() -> list[IPluginRequirement]

      Retrieve the requirements for this plugin.

      This method is called right after `init()` and the ownership the requirements is

      :returns: The list of requirements for this plugin.



   .. py:method:: settings() -> Sequence[PluginSetting]
      :abstractmethod:


      :returns: A list of settings for this plugin.



   .. py:method:: version() -> VersionInfo
      :abstractmethod:


      :returns: The version of this plugin.



.. py:class:: IPluginDiagnose

   Bases: :py:obj:`IPlugin`


   Plugins that create problem reports to be displayed in the UI.

   This can be used to report problems related to the same plugin (which implements further
   interfaces) or as a stand-alone diagnosis tool.


   .. py:method:: _invalidate() -> None

      Invalidate the problems corresponding to this plugin.



   .. py:method:: activeProblems() -> list[int]
      :abstractmethod:


      Retrieve the list of active problems found by this plugin.

      This method returns a list of problem IDs, that are then used when calling other methods
      such as `shortDescription()` or `hasGuidedFix()`.

      :returns: The list of active problems for this plugin.



   .. py:method:: fullDescription(key: int) -> str
      :abstractmethod:


      Retrieve the full description of the problem corresponding to the given key.

      :param key: ID of the problem.

      :returns: The full description of the problem.

      :raises IndexError: If the key is not valid.



   .. py:method:: hasGuidedFix(key: int) -> bool
      :abstractmethod:


      Check if the problem corresponding to the given key has a guided fix.

      :param key: ID of the problem.

      :returns: True if there is a guided fix for the problem, False otherwise.

      :raises IndexError: If the key is not valid.



   .. py:method:: shortDescription(key: int) -> str
      :abstractmethod:


      Retrieve the short description of the problem corresponding to the given key.

      :param key: ID of the problem.

      :returns: The short description of the problem.

      :raises IndexError: If the key is not valid.



   .. py:method:: startGuidedFix(key: int) -> None
      :abstractmethod:


      Starts a guided fix for the problem corresponding to the given key.

      This method should throw `ValueError` if there is no guided fix for the corresponding
      problem.

      :param key: ID of the problem.

      :raises IndexError: If the key is not valid.
      :raises ValueError: If there is no guided fix for this problem.



.. py:class:: IPluginFileMapper

   Bases: :py:obj:`IPlugin`


   Plugins that adds virtual file links.


   .. py:method:: mappings() -> list[Mapping]
      :abstractmethod:


      :returns: Mapping for the virtual file system (VFS).



.. py:class:: IPluginGame

   Bases: :py:obj:`IPlugin`


   Base classes for game plugins.

   Each game requires a specific game plugin. These plugins were initially designed for
   Bethesda games, so a lot of methods and attributes are irrelevant for other games. If
   you wish to write a plugin for a much simpler game, please consider the `basic_games`
   plugin: https://github.com/ModOrganizer2/modorganizer-basic_games


   .. py:method:: CCPlugins() -> Sequence[str]

      :returns: The current list of active Creation Club plugins.



   .. py:method:: DLCPlugins() -> Sequence[str]

      :returns: The list of esp/esm files that are part of known DLCs.



   .. py:method:: binaryName() -> str
      :abstractmethod:


      :returns: The name of the default executable to run (relative to the game folder).



   .. py:method:: dataDirectory() -> PyQt6.QtCore.QDir
      :abstractmethod:


      :returns: The path to the directory containing data (absolute path).



   .. py:method:: detectGame() -> None
      :abstractmethod:


      Detect the game.

      This method is the first called for game plugins (before `init()`). The following
      methods should work properly after the call to `detectGame()` (and before `init()`):

        - gameName()
        - isInstalled()
        - gameIcon()
        - gameDirectory()
        - dataDirectory()
        - gameVariants()
        - looksValid()

      See `IPlugin.init()` for more.



   .. py:method:: displayGameName() -> str

      :returns: The name of the game to user for display, default to gameName().



   .. py:method:: documentsDirectory() -> PyQt6.QtCore.QDir
      :abstractmethod:


      :returns: The directory of the documents folder where configuration files and such for this game reside.



   .. py:method:: enabledPlugins() -> Sequence[str]

      :returns: A list of plugins enabled by the game but not in a strict load order.



   .. py:method:: executableForcedLoads() -> Sequence[ExecutableForcedLoadSetting]
      :abstractmethod:


      :returns: A list of automatically discovered libraries that can be force loaded with executables.



   .. py:method:: executables() -> Sequence[ExecutableInfo]

      :returns: A list of automatically discovered executables of the game itself and tools surrounding it.



   .. py:method:: gameDirectory() -> PyQt6.QtCore.QDir
      :abstractmethod:


      :returns: The directory containing the game installation.



   .. py:method:: gameIcon() -> PyQt6.QtGui.QIcon
      :abstractmethod:


      :returns: The icon representing the game.



   .. py:method:: gameName() -> str
      :abstractmethod:


      :returns: The name of the game (for internal usage).



   .. py:method:: gameNexusName() -> str

      :returns: The name of the game identifier for Nexus.



   .. py:method:: gameShortName() -> str
      :abstractmethod:


      :returns: The short name of the game.



   .. py:method:: gameVariants() -> Sequence[str]

      Retrieve the list of variants for this game.

      If there are multiple variants of a game (and the variants make a difference to the
      plugin), like a regular one and a GOTY-edition, the plugin can return a list of them
      and the user gets to chose which one he owns.

      :returns: The list of variants of the game.



   .. py:method:: gameVersion() -> str
      :abstractmethod:


      :returns: The version of the game.



   .. py:method:: getLauncherName() -> str
      :abstractmethod:


      :returns: The name of the launcher executable to run (relative to the game folder), or an

      empty string if there is no launcher.



   .. py:method:: getSupportURL() -> str
      :abstractmethod:


      :returns: An URL for the support page of this game.



   .. py:method:: iniFiles() -> Sequence[str]

      :returns: The list of INI files this game uses. The first file in the list should be the

      'main' INI file.



   .. py:method:: initializeProfile(directory: PyQt6.QtCore.QDir, settings: ProfileSetting) -> None
      :abstractmethod:


      Initialize a profile for this game.

      The MO app does not yet support virtualizing only specific aspects but plugins should be written
      with this future functionality in mind.

      This function will be used to initially create a profile, potentially to repair it or upgrade/downgrade
      it so the implementations have to gracefully handle the case that the directory already contains files.

      :param directory: The directory where the profile is to be initialized.
      :param settings: The parameters for how the profile should be initialized.



   .. py:method:: isInstalled() -> bool
      :abstractmethod:


      :returns: True if this game has been discovered as installed, False otherwise.



   .. py:method:: listSaves(folder: PyQt6.QtCore.QDir) -> list[ISaveGame]
      :abstractmethod:


      List saves in the given directory.

      :param folder: The folder to list saves from.

      :returns: The list of game saves in the given folder.



   .. py:method:: loadOrderMechanism() -> LoadOrderMechanism

      :returns: The load order mechanism used by this game.



   .. py:method:: looksValid(directory: PyQt6.QtCore.QDir) -> bool
      :abstractmethod:


      Check if the given directory looks like a valid game installation.

      :param directory: Directory to check.

      :returns: True if the directory looks like a valid installation of this game, False otherwise.



   .. py:method:: lootGameName() -> str

      :returns: The game name to use when calling LOOT from MO2, default to gameShortName().



   .. py:method:: nexusGameID() -> int
      :abstractmethod:


      Retrieve the Nexus game ID for this game.

      Example: For Skyrim, the Nexus game ID is 110.

      :returns: The Nexus game ID for this game.



   .. py:method:: nexusModOrganizerID() -> int

      Retrieve the Nexus mod ID of Mod Organizer for this game.

      Example: For Skyrim SE, the mod ID of MO2 is 6194. You can find the mod ID in the URL:
        https://www.nexusmods.com/skyrimspecialedition/mods/6194

      :returns: The Nexus mod ID of Mod Organizer for this game.



   .. py:method:: primaryPlugins() -> Sequence[str]

      :returns: The list of plugins that are part of the game and not considered optional.



   .. py:method:: primarySources() -> Sequence[str]

      Retrieve primary alternative 'short' names for this game.

      This is used to determine if a Nexus (or other) download source should be considered
      as a primary source for the game so that it is not flagged as an alternative one.

      :returns: The list of primary alternative 'short' names for this game, or an empty list.



   .. py:method:: savesDirectory() -> PyQt6.QtCore.QDir
      :abstractmethod:


      :returns: The directory where save games are stored.



   .. py:method:: secondaryDataDirectories() -> Dict[str, PyQt6.QtCore.QDir]

      Retrieve the list of secondary data directories. Each directories should be
      assigned a unique name that differs from "data" which is the name of the main
      data directory returned by dataDirectory().

      :returns: A mapping from unique name to secondary data directories.



   .. py:method:: setGamePath(path: str) -> None
      :abstractmethod:


      Set the path to the managed game.

      This is called during instance creation if the game is not auto-detected and the user has
      to specify the installation location. This is not called if the game has been auto-detected,
      so `isInstalled()` should call this.

      :param path: Path to the game installation.



   .. py:method:: setGameVariant(variant: str) -> None
      :abstractmethod:


      Set the game variant.

      If there are multiple variants of game (as returned by `gameVariants()`), this will be
      called on start with the user-selected game variant.

      :param variant: The game variant selected by the user.



   .. py:method:: sortMechanism() -> SortMechanism

      :returns: The sort mechanism for this game.



   .. py:method:: steamAPPId() -> str

      Retrieve the Steam app ID for this game.

      If the game is not available on Steam, this should return an empty string.

      If a game is available in multiple versions, those might have different app ids. The plugin
      should try to return the right one

      :returns: The Steam app ID for this game. Should be empty for games not available on steam.



   .. py:method:: validShortNames() -> Sequence[str]
      :abstractmethod:


      Retrieve the valid 'short' names for this game.

      This is used to determine if a Nexus download is valid for the current game since not all
      game variants have their own nexus pages and others can handle downloads from other nexus
      game pages and should be allowed to do so (e.g., you can install some Skyrim LE mod even
      when using Skyrim SE).

      The short name should be considered the primary handler for a directly supported game
      for purposes of auto-launching an instance.

      :returns: The list of valid short names for this game.



.. py:class:: IPluginInstaller

   Bases: :py:obj:`IPlugin`


   This is the top-level class for installer. Actual installers should inherit either:

     - `IPluginInstallerSimple` if the installer can work directly with the archive. This is what
       most installers use.
     - `IPluginInstallerCustom` if the installer needs to perform custom operations. This is only
       used by the external NCC installer and the OMOD installer.


   .. py:method:: _manager() -> IInstallationManager

      :returns: The installation manager.



   .. py:method:: _parentWidget() -> PyQt6.QtWidgets.QWidget

      :returns: The parent widget.



   .. py:method:: isArchiveSupported(tree: IFileTree) -> bool
      :abstractmethod:


      Check if the given file tree corresponds to a supported archive for this installer.

      :param tree: The tree representing the content of the archive.

      :returns: True if this installer can handle the archive, False otherwise.



   .. py:method:: isManualInstaller() -> bool
      :abstractmethod:


      Check if this installer is a manual installer.

      :returns: True if this installer is a manual installer, False otherwise.



   .. py:method:: onInstallationEnd(result: InstallResult, new_mod: IModInterface) -> None

      Method calls at the end of the installation process. This method is only called once
      per installation process, even for recursive installations (e.g. with the bundle installer).

      :param result: The result of the installation.
      :param new_mod: If the installation succeeded (result is RESULT_SUCCESS), contains the newly
                      installed mod, otherwise it contains a null pointer.



   .. py:method:: onInstallationStart(archive: str, reinstallation: bool, current_mod: IModInterface) -> None

      Method calls at the start of the installation process, before any other methods.
      This method is only called once per installation process, even for recursive
      installations (e.g. with the bundle installer).

      If `reinstallation` is true, then the given mod is the mod being reinstalled (the one
      selected by the user). If `reinstallation` is false and `currentMod` is not null, then
      it corresponds to a mod MO2 thinks corresponds to the archive (e.g. based on matching Nexus ID
      or name).

      The default implementation does nothing.

      :param archive: Path to the archive that is going to be installed.
      :param reinstallation: True if this is a reinstallation, False otherwise.
      :param current_mod: A currently installed mod corresponding to the archive being installed, or None
                          if there is no such mod.



   .. py:method:: priority() -> int
      :abstractmethod:


      Retrieve the priority of this installer.

      If multiple installers are able to handle an archive, the one with the highest priority wins.

      :returns: The priority of this installer.



   .. py:method:: setInstallationManager(manager: IInstallationManager) -> None

      Set the installation manager for this installer.

      Python plugins usually do not need to re-implement this and can directly access the installation
      manager using `_manager()`.

      :param manager: The installation manager.



   .. py:method:: setParentWidget(parent: PyQt6.QtWidgets.QWidget) -> None

      Set the parent widget for this installer.

      Python plugins usually do not need to re-implement this and can directly access the parent
      widget using `_parentWidget()` once the UI has been initialized.

      :param parent: The parent widget.



.. py:class:: IPluginInstallerCustom

   Bases: :py:obj:`IPluginInstaller`


   Custom installer for mods. Custom installers receive the archive name and have to go
   from there. They have to be able to extract the archive themselves.

   Example of such installers are the external NCC installer or the OMOD installer.


   .. py:method:: install(mod_name: GuessedString, game_name: str, archive_name: str, version: str, nexus_id: int) -> InstallResult
      :abstractmethod:


      Install the given archive.

      The mod needs to be created by calling `IOrganizer.createMod` first.

      :param mod_name: Name of the mod to install. As an input parameter this is the suggested name
                       (e.g. from meta data) The installer may change this parameter to rename the mod).
      :param game_name: Name of the game for which the mod is installed.
      :param archive_name: Name of the archive to install.
      :param version: Version of the mod. May be empty if the version is not yet known. The plugin is responsible
                      for setting the version on the created mod.
      :param nexus_id: ID of the mod or -1 if unknown. The plugin is responsible for setting the mod ID for the
                       created mod.

      :returns: The result of the installation process.



   .. py:method:: isArchiveSupported(tree: IFileTree) -> bool
                  isArchiveSupported(archive_name: str) -> bool
      :abstractmethod:


      Check if the given file is a supported archive for this installer.

      :param archive_name: Name of the archive.

      :returns: True if this installer can handle the archive, False otherwise.



   .. py:method:: supportedExtensions() -> set[str]
      :abstractmethod:


      :returns: A list of file extensions that this installer can handle.



.. py:class:: IPluginInstallerSimple

   Bases: :py:obj:`IPluginInstaller`


   Simple installer for mods. Simple installers only deal with an in-memory structure
   representing the archive and can modify what to install and where by editing this structure.
   Actually extracting the archive is handled by the manager.


   .. py:method:: install(name: GuessedString, tree: IFileTree, version: str, nexus_id: int) -> Union[InstallResult, IFileTree, tuple[InstallResult, IFileTree, str, int]]
      :abstractmethod:


      Install a mod from an archive filetree.

      The installer can modify the given tree and use the manager to extract or create new
      files.

      This method returns different type of objects depending on the actual result of the
      installation. The C++ bindings for this method always returns a tuple (result, tree,
      version, id).

      :param name: Name of the mod to install. As an input parameter this is the suggested name
                   (e.g. from meta data) The installer may change this parameter to rename the mod).
      :param tree: In-memory representation of the archive content.
      :param version: Version of the mod, or an empty string is unknown.
      :param nexus_id: ID of the mod, or -1 if unknown.

      :returns: In case of failure, the result of the installation, otherwise the modified tree or

      a tuple (result, tree, version, id) containing the result of the installation, the
      modified tree, the new version and the new ID. The tuple can be returned even if the
      installation did not succeed.



.. py:class:: IPluginList

   Primary interface to the list of plugins.


   .. py:method:: hasLightExtension(name: str) -> bool

      Determine if a plugin has a .esl extension.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given file has a .esl extension, False otherwise or if the

      file does not exist.



   .. py:method:: hasMasterExtension(name: str) -> bool

      Determine if a plugin has a .esm extension.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given file has a .esm extension, False otherwise or if the

      file does not exist.



   .. py:method:: hasNoRecords(name: str) -> bool

      Determine if a plugin has no records.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given file plugin contains no records, False if it does OR if the

      file does not exist.



   .. py:method:: isLightFlagged(name: str) -> bool

      Determine if a plugin is flagged as light.

      In gamebryo games, a master file will usually have a .esl file extension but
      technically an esp can be flagged as light.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given plugin is a light plugin, False otherwise or if the

      file does not exist.



   .. py:method:: isMasterFlagged(name: str) -> bool

      Determine if a plugin is flagged as mater, i.e., a library, reference by
      other plugins.

      In gamebryo games, a master file will usually have a .esm file extension but
      technically an esp can be flagged as master and an esm might not be.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given plugin is a master plugin, False otherwise or if the

      file does not exist.



   .. py:method:: isMediumFlagged(name: str) -> bool

      Determine if a plugin is flagged as medium.

      This plugin flag was added in Starfield and signifies plugin records that
      update existing records

      :param name: Filename of the plugin (without path but with file extension).

      :returns: True if the given plugin is a medium plugin, False otherwise or if the

      file does not exist.



   .. py:method:: loadOrder(name: str) -> int

      Retrieve the load order of a plugin.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: The load order of the plugin (the order in which the game loads it). If all plugins are enabled this

      is the same as the priority but disabled plugins will have a load order of -1. This also returns -1
      if the plugin does not exist.



   .. py:method:: masters(name: str) -> Sequence[str]

      Retrieve the list of masters required for a plugin.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: The list of masters for the plugin (filenames with extension, no path).



   .. py:method:: onPluginMoved(callback: Callable[[str, int, int], None]) -> bool

      Install a new handler to be called when a plugin is moved.

      :param callback: The function to call when a plugin is moved. The first parameter is the plugin name, the
                       second the old priority of the plugin and the third one the new priority.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onPluginStateChanged(callback: Callable[[dict[str, PluginState]], None]) -> bool

      Install a new handler to be called when plugin states change.

      :param callback: The function to call when a plugin states change. The parameter is a map from plugin names to new
                       plugin states for the plugin whose states have changed.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: onRefreshed(callback: Callable[[], None]) -> bool

      Install a new handler to be called when the list of plugins is refreshed.

      :param callback: The function to call when the list of plugins is refreshed.

      :returns: True if the handler was installed properly (there are currently no reasons for this to fail).



   .. py:method:: origin(name: str) -> str

      Retrieve the origin of a plugin. This is either the (internal) name of a mod, `"overwrite"` or `"data"`.

      The internal name of a mod can differ from the display name for disambiguation.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: The name of the origin of the plugin, or an empty string if the plugin does not exist.



   .. py:method:: pluginNames() -> Sequence[str]

      :returns: The list of all plugin names.



   .. py:method:: priority(name: str) -> int

      Retrieve the priority of a plugin.

      The higher the priority, the more important.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: The priority of the given plugin, or -1 if the plugin does not exist.



   .. py:method:: setLoadOrder(loadorder: Sequence[str]) -> None

      Set the load order.

      Plugins not included in the list will be placed at highest priority in the order they
      were before.

      :param loadorder: The new load order, specified by the list of plugin names, sorted.



   .. py:method:: setPriority(name: str, priority: int) -> bool

      Change the priority of a plugin.

      :param name: Filename of the plugin (without path but with file extension).
      :param priority: New priority of the plugin.

      :returns: True on success, False if the priority change was not possible. This is usually because

      one of the parameters is invalid. The function returns true even if the plugin was not moved
      at the specified priority (e.g. when trying to move a non-master plugin before a master one).



   .. py:method:: setState(name: str, state: PluginState) -> None

      Set the state of a plugin.

      :param name: Filename of the plugin (without path but with file extension).
      :param state: New state of the plugin (`INACTIVE` or `ACTIVE`).



   .. py:method:: state(name: str) -> PluginState

      Retrieve the state of a plugin.

      :param name: Filename of the plugin (without path but with file extension).

      :returns: The state of the plugin.



.. py:class:: IPluginModPage

   Bases: :py:obj:`IPlugin`


   Base class for all plugins.


   .. py:method:: _parentWidget() -> PyQt6.QtWidgets.QWidget

      :returns: The parent widget.



   .. py:method:: displayName() -> str
      :abstractmethod:


      :returns: The name of the page as displayed in the UI.



   .. py:method:: handlesDownload(page_url: PyQt6.QtCore.QUrl, download_url: PyQt6.QtCore.QUrl, fileinfo: ModRepositoryFileInfo) -> bool
      :abstractmethod:


      Check if the plugin handles the specified download.

      :param page_url: URL of the page that contains the download link.
      :param download_url: The download URL.
      :param fileinfo: Not usable in python.

      :returns: True if this plugin wants to handle the specified download, False otherwise.



   .. py:method:: icon() -> PyQt6.QtGui.QIcon
      :abstractmethod:


      :returns: The icon to display with the page.



   .. py:method:: pageURL() -> PyQt6.QtCore.QUrl
      :abstractmethod:


      :returns: The URL to open when the user wants to visit this mod page.



   .. py:method:: setParentWidget(parent: PyQt6.QtWidgets.QWidget) -> None

      Set the parent widget for this mod page.

      Python plugins usually do not need to re-implement this and can directly access the parent
      widget using `_parentWidget()` once the UI has been initialized.

      :param parent: The parent widget.



   .. py:method:: useIntegratedBrowser() -> bool
      :abstractmethod:


      Indicates if the page should be displayed in the integrated browser.

      Unless the page provides a special means of starting downloads (like the nxm:// url schema
      on nexus),  it will not be possible to handle downloads unless the integrated browser is used!

      :returns: True if the page should be opened in the integrated browser, False otherwise.



.. py:class:: IPluginPreview

   Bases: :py:obj:`IPlugin`


   These plugins add support for previewing files in the data pane. Right now all image formats supported
   by qt are implemented (including dds) but no audio files and no 3d mesh formats.


   .. py:method:: genDataPreview(file_data: PyQt6.QtCore.QByteArray, filename: str, max_size: PyQt6.QtCore.QSize) -> PyQt6.QtWidgets.QWidget
      :abstractmethod:


      Generate a preview widget from in-memory data.

      :param file_data: In-memory data to preview.
      :param filename: Name of the file the data comes from.
      :param max_size: Maximum size of the generated widget.

      :returns: The widget showing a preview of the in-memory data.



   .. py:method:: genFilePreview(filename: str, max_size: PyQt6.QtCore.QSize) -> PyQt6.QtWidgets.QWidget
      :abstractmethod:


      Generate a preview widget for the specified file.

      :param filename: Path to the file to preview.
      :param max_size: Maximum size of the generated widget.

      :returns: The widget showing a preview of the file.



   .. py:method:: supportedExtensions() -> set[str]
      :abstractmethod:


      :returns: The list of file extensions that are supported by this preview plugin.



   .. py:method:: supportsArchives() -> bool
      :abstractmethod:


      Check if this preview plugin supports preview from in-memory data.

      :returns: True if the plugin supports preview from raw data, False otherwise.



.. py:class:: IPluginRequirement

   Class representing requirements for plugins.


   .. py:class:: Problem(short_description: str, long_description: str = '')

      Class representing a problem found by a requirement.


      .. py:method:: longDescription() -> str

         :returns: A long description of the problem.



      .. py:method:: shortDescription() -> str

         :returns: A short description of the problem.




   .. py:method:: check(organizer: IOrganizer) -> Optional[IPluginRequirement]

      Check if the requirement is met, and return a problem if not.

      :param organizer: The IOrganizer instance.

      :returns: The problem found if the requirement is not met, otherwise None.



.. py:class:: IPluginTool

   Bases: :py:obj:`IPlugin`


   This is the simplest of plugin interfaces. Such plugins simply place an icon inside the tools sub-menu
   and get invoked when the user clicks it. They are expected to have a user interface of some sort. These
   are almost like independent applications except they can access all Mod Organizer interfaces like querying
   and modifying the current profile, mod list, load order, use MO to install mods and so on. A tool plugin
   can (and should!) integrate its UI as a window inside MO and thus doesn't have to initialize a windows
   application itself.


   .. py:method:: _parentWidget() -> PyQt6.QtWidgets.QWidget

      :returns: The parent widget.



   .. py:method:: display() -> None
      :abstractmethod:


      Called when the user starts the tool.



   .. py:method:: displayName() -> str
      :abstractmethod:


      :returns: The display name for this tool, as shown in the tool menu.



   .. py:method:: icon() -> PyQt6.QtGui.QIcon
      :abstractmethod:


      :returns: The icon for this tool, or a default-constructed QICon().



   .. py:method:: setParentWidget(parent: PyQt6.QtWidgets.QWidget) -> None

      Set the parent widget for this tool.

      Python plugins usually do not need to re-implement this and can directly access the parent
      widget using `_parentWidget()` once the UI has been initialized.

      :param parent: The parent widget.



   .. py:method:: tooltip() -> str
      :abstractmethod:


      :returns: The tooltip for this tool.



.. py:class:: IProfile

   Interface to interact with Mod Organizer 2 profiles.


   .. py:method:: absoluteIniFilePath(inifile: str) -> str

      Retrieve the absolute file path to the corresponding INI file for this profile.

      If iniFile does not correspond to a file in the list of INI files for the
      current game (as returned by IPluginGame::iniFiles), the path to the global
      file will be returned (if iniFile is absolute, iniFile is returned, otherwise
      the path is assumed relative to the game documents directory).

      :param inifile: INI file to retrieve a path for. This can either be the name of a file or a path to the
                      absolute file outside of the profile.

      :returns: The absolute path for the given INI file for this profile.



   .. py:method:: absolutePath() -> str

      :returns: The absolute path to the profile folder.



   .. py:method:: invalidationActive() -> tuple[bool, bool]

      :returns: True if automatic archive invalidation is enabled for this profile, False otherwise.



   .. py:method:: localSavesEnabled() -> bool

      :returns: True if profile-specific saves are enabled for this profile, False otherwise.



   .. py:method:: localSettingsEnabled() -> bool

      :returns: True if profile-specific game settings are enabled for this profile, False otherwise.



   .. py:method:: name() -> str

      :returns: The name of this profile.



.. py:class:: ISaveGame

   Base class for information about what is in a save game.


   .. py:method:: allFiles() -> Sequence[Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]]

      :returns: The list of all files related to this save.



   .. py:method:: getCreationTime() -> PyQt6.QtCore.QDateTime

      Retrieve the creation time of the save.

      The creation time of a save is not always the same as the creation time of
      the file containing the save.

      :returns: The creation time of the save.



   .. py:method:: getFilepath() -> Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]

      :returns: The path name to the (main) file or folder for the save.



   .. py:method:: getName() -> str

      :returns: The name of this save, for display purpose.



   .. py:method:: getSaveGroupIdentifier() -> str

      Retrieve the name of the group this files belong to.

      The name can be used to identify sets of saves to transfer between profiles. For
      RPG games, this is usually the name of a character.

      :returns: The group identifier for this save game.



.. py:class:: ISaveGameInfoWidget(parent: PyQt6.QtWidgets.QWidget | None = None)

   Bases: :py:obj:`PyQt6.QtWidgets.QWidget`


   Base class for a save game info widget.


   .. py:method:: __getattr__(arg0: str) -> object


   .. py:method:: _widget() -> PyQt6.QtWidgets.QWidget

      :returns: The underlying `QWidget`.



   .. py:method:: setSave(save: ISaveGame) -> None
      :abstractmethod:


      Set the save file to display in this widget.

      :param save: The save to display in the widget



.. py:class:: InstallResult(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: CANCELED
      :value: Ellipsis



   .. py:attribute:: FAILED
      :value: Ellipsis



   .. py:attribute:: MANUAL_REQUESTED
      :value: Ellipsis



   .. py:attribute:: NOT_ATTEMPTED
      :value: Ellipsis



   .. py:attribute:: SUCCESS
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: LoadOrderMechanism(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: FILE_TIME
      :value: Ellipsis



   .. py:attribute:: NONE
      :value: Ellipsis



   .. py:attribute:: PLUGINS_TXT
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: LocalSavegames

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: mappings(profile_save_dir: PyQt6.QtCore.QDir) -> list[Mapping]
      :abstractmethod:



   .. py:method:: prepareProfile(profile: IProfile) -> bool
      :abstractmethod:



.. py:class:: Mapping
              Mapping(source: str, destination: str, is_directory: bool, create_target: bool = False)

   .. py:method:: __str__() -> str

      Return str(self).



   .. py:property:: createTarget
      :type: bool



   .. py:property:: destination
      :type: str



   .. py:property:: isDirectory
      :type: bool



   .. py:property:: source
      :type: str



.. py:class:: ModDataChecker

   Bases: :py:obj:`GameFeature`


   Game feature that is used to check the content of a data tree.


   .. py:class:: CheckReturn(*args, **kwds)

      Bases: :py:obj:`enum.Enum`


      Create a collection of name/value pairs.

      Example enumeration:

      >>> class Color(Enum):
      ...     RED = 1
      ...     BLUE = 2
      ...     GREEN = 3

      Access them by:

      - attribute access:

        >>> Color.RED
        <Color.RED: 1>

      - value lookup:

        >>> Color(1)
        <Color.RED: 1>

      - name lookup:

        >>> Color['RED']
        <Color.RED: 1>

      Enumerations can be iterated over, and know how many members they have:

      >>> len(Color)
      3

      >>> list(Color)
      [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

      Methods can be added to enumerations, and members can have their own
      attributes -- see the documentation for details.


      .. py:method:: __eq__(other: object) -> bool

         Return self==value.



      .. py:method:: __int__() -> int


      .. py:method:: __ne__(other: object) -> bool

         Return self!=value.



      .. py:method:: __str__() -> str

         Return str(self).



      .. py:attribute:: FIXABLE
         :value: Ellipsis



      .. py:attribute:: INVALID
         :value: Ellipsis



      .. py:attribute:: VALID
         :value: Ellipsis



      .. py:property:: name
         :type: str

         The name of the Enum member.


      .. py:property:: value
         :type: int

         The value of the Enum member.



   .. py:method:: dataLooksValid(filetree: IFileTree) -> ModDataChecker
      :abstractmethod:


      Check that the given filetree represent a valid mod layout, or can be easily
      fixed.

      This method is mainly used during installation (to find which installer should
      be used or to recurse into multi-level archives), or to quickly indicates to a
      user if a mod looks valid.

      This method does not have to be exact, it only has to indicate if the given tree
      looks like a valid mod or not by quickly checking the structure (heavy operations
      should be avoided).

      If the tree can be fixed by the `fix()` method, this method should return `FIXABLE`.
      `FIXABLE` should only be returned when it is guaranteed that `fix()` can fix the tree.

      :param filetree: The tree starting at the root of the "data" folder.

      :returns: Whether the tree is invalid, fixable or valid.



   .. py:method:: fix(filetree: IFileTree) -> IFileTree | None

      Try to fix the given tree.

      This method is used during installation to try to fix invalid archives and will only be
      called if dataLooksValid returned `FIXABLE`.

      :param filetree: The tree to try to fix. Can be modified during the process.

      :returns: The fixed tree, or a null pointer if the tree could not be fixed.



   .. py:attribute:: FIXABLE
      :type:  ModDataChecker.CheckReturn
      :value: Ellipsis



   .. py:attribute:: INVALID
      :type:  ModDataChecker.CheckReturn
      :value: Ellipsis



   .. py:attribute:: VALID
      :type:  ModDataChecker.CheckReturn
      :value: Ellipsis



.. py:class:: ModDataContent

   Bases: :py:obj:`GameFeature`


   The ModDataContent feature is used (when available) to indicate to users the content
   of mods in the "Content" column.

   The feature exposes a list of possible content types, each associated with an ID, a name
   and an icon. The icon is the path to either:

     - A Qt resource or;
     - A file on the disk.

   In order to facilitate the implementation, MO2 already provides a set of icons that can
   be used. Those icons are all under ``:/MO/gui/content`` (e.g. ``:/MO/gui/content/plugin`` or ``:/MO/gui/content/music`` `).

   The list of available icons is:

     - ``plugin``: |plugin-icon|
     - ``skyproc``: |skyproc-icon|
     - ``texture``: |texture-icon|
     - ``music``: |music-icon|
     - ``sound``: |sound-icon|
     - ``interface``: |interface-icon|
     - ``skse``: |skse-icon|
     - ``script``: |script-icon|
     - ``mesh``: |mesh-icon|
     - ``string``: |string-icon|
     - ``bsa``: |bsa-icon|
     - ``menu``: |menu-icon|
     - ``inifile``: |inifile-icon|
     - ``modgroup``: |modgroup-icon|

   .. |plugin-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/jigsaw-piece.png
   .. |skyproc-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/hand-of-god.png
   .. |texture-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/empty-chessboard.png
   .. |music-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/double-quaver.png
   .. |sound-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/lyre.png
   .. |interface-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/usable.png
   .. |skse-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/checkbox-tree.png
   .. |script-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/tinker.png
   .. |mesh-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/breastplate.png
   .. |string-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/conversation.png
   .. |bsa-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/locked-chest.png
   .. |menu-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/config.png
   .. |inifile-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/feather-and-scroll.png
   .. |modgroup-icon| image:: https://raw.githubusercontent.com/ModOrganizer2/modorganizer/master/src/resources/contents/xedit.png


   .. py:class:: Content(id: int, name: str, icon: str, filter_only: bool = False)

      .. py:method:: isOnlyForFilter() -> bool

         :returns: True if this content is only meant to be used as a filter criteria.



      .. py:property:: icon
         :type: str



      .. py:property:: id
         :type: int



      .. py:property:: name
         :type: str




   .. py:method:: getAllContents() -> list[ModDataContent]
      :abstractmethod:


      :returns: The list of all possible contents for the corresponding game.



   .. py:method:: getContentsFor(filetree: IFileTree) -> list[int]
      :abstractmethod:


      Retrieve the list of contents in the given tree.

      :param filetree: The tree corresponding to the mod to retrieve contents for.

      :returns: The IDs of the content in the given tree.



.. py:class:: ModRepositoryFileInfo(other: ModRepositoryFileInfo)
              ModRepositoryFileInfo(game_name: str = '', mod_id: int = 0, file_id: int = 0)

   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: createFromJson(data: str) -> ModRepositoryFileInfo
      :staticmethod:



   .. py:property:: categoryID
      :type: int



   .. py:property:: description
      :type: str



   .. py:property:: fileCategory
      :type: int



   .. py:property:: fileID
      :type: int



   .. py:property:: fileName
      :type: str



   .. py:property:: fileSize
      :type: int



   .. py:property:: fileTime
      :type: PyQt6.QtCore.QDateTime



   .. py:property:: gameName
      :type: str



   .. py:property:: modID
      :type: int



   .. py:property:: modName
      :type: str



   .. py:property:: name
      :type: str



   .. py:property:: newestVersion
      :type: VersionInfo



   .. py:property:: repository
      :type: str



   .. py:property:: uri
      :type: str



   .. py:property:: userData
      :type: MoVariant



   .. py:property:: version
      :type: VersionInfo



.. py:class:: ModState(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __and__(other: ModState) -> ModState


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(other: ModState) -> bool

      Return self>=value.



   .. py:method:: __gt__(other: ModState) -> bool

      Return self>value.



   .. py:method:: __int__() -> int


   .. py:method:: __invert__() -> ModState


   .. py:method:: __le__(other: ModState) -> bool

      Return self<=value.



   .. py:method:: __lt__(other: ModState) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __or__(other: ModState) -> ModState


   .. py:method:: __rand__(other: ModState) -> ModState


   .. py:method:: __ror__(other: ModState) -> ModState


   .. py:method:: __rxor__(other: ModState) -> ModState


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __xor__(other: ModState) -> ModState


   .. py:attribute:: ACTIVE
      :value: Ellipsis



   .. py:attribute:: ALTERNATE
      :value: Ellipsis



   .. py:attribute:: EMPTY
      :value: Ellipsis



   .. py:attribute:: ENDORSED
      :value: Ellipsis



   .. py:attribute:: ESSENTIAL
      :value: Ellipsis



   .. py:attribute:: EXISTS
      :value: Ellipsis



   .. py:attribute:: VALID
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: PluginRequirementFactory

   .. py:method:: basic(checker: Callable[[IOrganizer], bool], description: str) -> IPluginRequirement
      :staticmethod:


      Create a basic requirement.

      :param checker: The callable to use to check if the requirement is met. Should return True
                      if the requirement is met, False otherwise.
      :param description: The description of the problem, when the requirement is not met.

      :returns: The constructed requirement.



   .. py:method:: diagnose(diagnose: IPluginDiagnose) -> IPluginRequirement
      :staticmethod:


      Construct a requirement from a diagnose plugin.

      If the wrapped diagnose plugin reports a problem, the requirement fails
      and the associated message is the one from the diagnose plugin (or the
      list of messages if multiple problems were reported).

      :param diagnose: The diagnose plugin to wrap in this requirement.

      :returns: The constructed requirement.



   .. py:method:: gameDependency(games: Sequence[str]) -> IPluginRequirement
                  gameDependency(game: str) -> IPluginRequirement
      :staticmethod:


      Create a new game dependency requirement.

      The requirement is met when the managed game is the specified game.

      :param game: The name of the required game.

      :returns: The constructed requirement.



   .. py:method:: pluginDependency(plugins: Sequence[str]) -> IPluginRequirement
                  pluginDependency(plugin: str) -> IPluginRequirement
      :staticmethod:


      Create a new plugin dependency requirement.

      The requirement is met when the specified plugin is enabled.

      :param plugin: The name of the plugin that must be enabled.

      :returns: The constructed requirement.



.. py:class:: PluginSetting(key: str, description: str, default_value: MoVariant)

   Class to hold the user-configurable parameters a plugin accepts. The purpose of this class is
   only to inform the application what settings to offer to the user, it does not hold the actual value.


   .. py:property:: default_value
      :type: MoVariant



   .. py:property:: description
      :type: str



   .. py:property:: key
      :type: str



.. py:class:: PluginState(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __and__(other: PluginState) -> PluginState


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(other: PluginState) -> bool

      Return self>=value.



   .. py:method:: __gt__(other: PluginState) -> bool

      Return self>value.



   .. py:method:: __int__() -> int


   .. py:method:: __invert__() -> PluginState


   .. py:method:: __le__(other: PluginState) -> bool

      Return self<=value.



   .. py:method:: __lt__(other: PluginState) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __or__(other: PluginState) -> PluginState


   .. py:method:: __rand__(other: PluginState) -> PluginState


   .. py:method:: __ror__(other: PluginState) -> PluginState


   .. py:method:: __rxor__(other: PluginState) -> PluginState


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __xor__(other: PluginState) -> PluginState


   .. py:attribute:: ACTIVE
      :value: Ellipsis



   .. py:attribute:: INACTIVE
      :value: Ellipsis



   .. py:attribute:: MISSING
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: ProfileSetting(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __and__(other: ProfileSetting) -> ProfileSetting


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(other: ProfileSetting) -> bool

      Return self>=value.



   .. py:method:: __gt__(other: ProfileSetting) -> bool

      Return self>value.



   .. py:method:: __int__() -> int


   .. py:method:: __invert__() -> ProfileSetting


   .. py:method:: __le__(other: ProfileSetting) -> bool

      Return self<=value.



   .. py:method:: __lt__(other: ProfileSetting) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __or__(other: ProfileSetting) -> ProfileSetting


   .. py:method:: __rand__(other: ProfileSetting) -> ProfileSetting


   .. py:method:: __ror__(other: ProfileSetting) -> ProfileSetting


   .. py:method:: __rxor__(other: ProfileSetting) -> ProfileSetting


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __xor__(other: ProfileSetting) -> ProfileSetting


   .. py:attribute:: CONFIGURATION
      :value: Ellipsis



   .. py:attribute:: MODS
      :value: Ellipsis



   .. py:attribute:: PREFER_DEFAULTS
      :value: Ellipsis



   .. py:attribute:: SAVEGAMES
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: ReleaseType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: ALPHA
      :value: Ellipsis



   .. py:attribute:: BETA
      :value: Ellipsis



   .. py:attribute:: CANDIDATE
      :value: Ellipsis



   .. py:attribute:: FINAL
      :value: Ellipsis



   .. py:attribute:: PRE_ALPHA
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: SaveGameInfo

   Bases: :py:obj:`GameFeature`


   Feature to get hold of stuff to do with save games.


   .. py:method:: getMissingAssets(save: ISaveGame) -> Dict[str, Sequence[str]]
      :abstractmethod:


      Retrieve missing assets from the save.

      :param save: The save to find missing assets for.

      :returns: A collection of missing assets and the modules that can supply those assets.



   .. py:method:: getSaveGameWidget(parent: PyQt6.QtWidgets.QWidget) -> ISaveGameInfoWidget | None
      :abstractmethod:


      Retrieve a widget to display over the save game list.

      This method is allowed to return `None` in case no widget has been implemented.

      :param parent: The parent widget.

      :returns: A SaveGameInfoWidget to display information about save game.



.. py:class:: ScriptExtender

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: binaryName() -> str
      :abstractmethod:


      :returns: The name of the script extender binary.



   .. py:method:: getArch() -> int
      :abstractmethod:


      :returns: The CPU platform of the extender.



   .. py:method:: getExtenderVersion() -> str
      :abstractmethod:


      :returns: The version of the script extender.



   .. py:method:: isInstalled() -> bool
      :abstractmethod:


      :returns: True if the script extender is installed, False otherwise.



   .. py:method:: loaderName() -> str
      :abstractmethod:


      :returns: The loader to use to ensure the game runs with the script extender.



   .. py:method:: loaderPath() -> Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]
      :abstractmethod:


      :returns: The full path to the script extender loader.



   .. py:method:: pluginPath() -> Union[str, os.PathLike[str], PyQt6.QtCore.QDir]
      :abstractmethod:


      :returns: The script extender plugin path, relative to the data folder.



   .. py:method:: savegameExtension() -> str
      :abstractmethod:


      Retrieve the extension of script extender save files.

      :returns: The extension of script extender save files (e.g. "skse").



.. py:class:: SortMechanism(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: BOSS
      :value: Ellipsis



   .. py:attribute:: LOOT
      :value: Ellipsis



   .. py:attribute:: MLOX
      :value: Ellipsis



   .. py:attribute:: NONE
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: TrackedState(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(other: TrackedState) -> bool

      Return self>=value.



   .. py:method:: __gt__(other: TrackedState) -> bool

      Return self>value.



   .. py:method:: __int__() -> int


   .. py:method:: __le__(other: TrackedState) -> bool

      Return self<=value.



   .. py:method:: __lt__(other: TrackedState) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: TRACKED_FALSE
      :value: Ellipsis



   .. py:attribute:: TRACKED_TRUE
      :value: Ellipsis



   .. py:attribute:: TRACKED_UNKNOWN
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:class:: UnmanagedMods

   Bases: :py:obj:`GameFeature`


   Base class for all game features, cannot be inherited, used only for typing
   purpose in Python.


   .. py:method:: displayName(mod_name: str) -> str
      :abstractmethod:


      Retrieve the display name of a given mod.

      :param mod_name: Internal name of the mod.

      :returns: The display name of the mod.



   .. py:method:: mods(official_only: bool) -> Sequence[str]
      :abstractmethod:


      Retrieve the list of unmanaged mods for the corresponding game.

      :param official_only: Retrieve only unmanaged official mods.

      :returns: The list of unmanaged mods (internal names).



   .. py:method:: referenceFile(mod_name: str) -> Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]
      :abstractmethod:


      Retrieve the reference file for the requested mod.

      Example: For Bethesda games, the reference file may be the main
      plugin (esp or esm) for the game or a DLCs.

      :param mod_name: Internal name of the mod.

      :returns: The reference file (absolute path) for the requested mod.



   .. py:method:: secondaryFiles(mod_name: str) -> Sequence[Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]]
      :abstractmethod:


      Retrieve the secondary files for the requested mod.

      Example: For Bethesda games, the secondary files may be the archives
      corresponding to the reference file.

      :param mod_name: Internal name of the mod.

      :returns: The secondary files (absolute paths) for the request mod.



.. py:class:: VersionInfo
              VersionInfo(value: str, scheme: VersionScheme = VersionScheme.DISCOVER)
              VersionInfo(major: int, minor: int, subminor: int, subsubminor: int, release_type: ReleaseType = ReleaseType.FINAL)
              VersionInfo(major: int, minor: int, subminor: int, release_type: ReleaseType = ReleaseType.FINAL)

   Represents the version of a mod or plugin.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __ge__(arg0: VersionInfo) -> bool

      Return self>=value.



   .. py:method:: __gt__(arg0: VersionInfo) -> bool

      Return self>value.



   .. py:method:: __le__(arg0: VersionInfo) -> bool

      Return self<=value.



   .. py:method:: __lt__(arg0: VersionInfo) -> bool

      Return self<value.



   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      :returns: See `canonicalString()`.



   .. py:method:: canonicalString() -> str

      :returns: A canonical string representing this version, that can be stored and then parsed using the parse() method.



   .. py:method:: clear() -> None

      Resets this VersionInfo to an invalid version.



   .. py:method:: displayString(forced_segments: int = 2) -> str

      :param forced_segments: The number of version segments to display even if the version is 0. 1 is major, 2 is major
                              and minor, etc. The only implemented ranges are (-inf,2] for major/minor, [3] for major/minor/subminor,
                              and [4,inf) for major/minor/subminor/subsubminor. This only versions with a regular scheme.

      :returns: A string for display to the user. The returned string may not contain enough information to reconstruct this version info.



   .. py:method:: isValid() -> bool

      :returns: True if this VersionInfo is valid, False otherwise.



   .. py:method:: parse(value: str, scheme: VersionScheme = VersionScheme.DISCOVER, is_manual: bool = False) -> None

      Update this VersionInfo by parsing the given string using the given scheme.

      :param value: String to parse.
      :param scheme: Scheme to use to parse the string.
      :param is_manual: True if the given string should be treated as user input.



   .. py:method:: scheme() -> VersionScheme

      :returns: The version scheme in effect for this VersionInfo.



.. py:class:: VersionScheme(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: __int__() -> int


   .. py:method:: __ne__(other: object) -> bool

      Return self!=value.



   .. py:method:: __str__() -> str

      Return str(self).



   .. py:attribute:: DATE
      :value: Ellipsis



   .. py:attribute:: DECIMAL_MARK
      :value: Ellipsis



   .. py:attribute:: DISCOVER
      :value: Ellipsis



   .. py:attribute:: LITERAL
      :value: Ellipsis



   .. py:attribute:: NUMBERS_AND_LETTERS
      :value: Ellipsis



   .. py:attribute:: REGULAR
      :value: Ellipsis



   .. py:property:: name
      :type: str

      The name of the Enum member.


   .. py:property:: value
      :type: int

      The value of the Enum member.


.. py:function:: getFileVersion(filepath: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]) -> str

   Retrieve the file version of the given executable.

   :param filepath: Absolute path to the executable.

   :returns: The file version, or an empty string if the file version could not be retrieved.


.. py:function:: getIconForExecutable(executable: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]) -> PyQt6.QtGui.QIcon

   Retrieve the icon of an executable. Currently this always extracts the biggest icon.

   :param executable: Absolute path to the executable.

   :returns: The icon for this executable, if any.


.. py:function:: getProductVersion(executable: Union[str, os.PathLike[str], PyQt6.QtCore.QFileInfo]) -> str

   Retrieve the product version of the given executable.

   :param executable: Absolute path to the executable.

   :returns: The product version, or an empty string if the product version could not be retrieved.


.. py:data:: GameFeatureType

.. py:data:: INVALID_HANDLE_VALUE
   :type:  int
   :value: Ellipsis


.. py:data:: MoVariant

.. py:data:: __version__
   :value: '2.5.2'


